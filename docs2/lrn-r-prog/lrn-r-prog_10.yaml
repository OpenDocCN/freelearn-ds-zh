- en: Chapter 10. Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 面向对象编程
- en: In the previous chapter, you learned how functional programming and metaprogramming
    make it possible to customize the behavior of functions. We can create a function
    within a certain context, which is called a closure. We can also use higher order
    functions by passing functions around just like other objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了函数式编程和元编程如何使自定义函数的行为成为可能。我们可以在某个特定上下文中创建一个函数，这被称为闭包。我们还可以通过传递函数就像传递其他对象一样来使用高阶函数。
- en: In this chapter, you will learn how to customize the behavior of objects by
    walking into the world of object-oriented programming. R provides several different
    object-oriented systems to work with. At first glance, they look quite different
    from the object-oriented systems in other programming languages. However, the
    idea is mostly the same. I will briefly explain the concept of class and method
    of objects, and show you how they can be useful in unifying the way we work with
    data and models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何通过进入面向对象编程的世界来自定义对象的行为。R提供了几个不同的面向对象系统来工作。乍一看，它们与其他编程语言中的面向对象系统看起来相当不同。然而，基本思想大多是相同的。我将简要解释对象类和方法的观念，并展示它们如何有助于统一我们处理数据和模型的方式。
- en: 'We will cover the following topics at the beginner level in the subsequent
    sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将从入门级别介绍以下主题：
- en: The idea of object-oriented programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程的思想
- en: S3 system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S3系统
- en: S4 system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S4系统
- en: Reference class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考类
- en: R6 package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R6包
- en: Finally, we will compare these systems in several aspects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从几个方面比较这些系统。
- en: Introducing object-oriented programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍面向对象编程
- en: If you are a developer from programming languages such as Java, Python, C++,
    C#, you should feel familiar with the object-oriented style of coding. However,
    if you are not familiar with any other object-oriented programming languages,
    you will probably be puzzled by this term, as it sounds a bit abstract. However,
    don't worry; this is much easier to understand than it looks if we think about
    the core of programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java、Python、C++、C#等编程语言的开发者，你应该对面向对象的编程风格感到熟悉。然而，如果你不熟悉任何其他面向对象的编程语言，你可能对这个术语感到困惑，因为它听起来有点抽象。但是，不用担心；如果我们从编程的核心来考虑，这比看起来要容易理解得多。
- en: When we talk about programming, we are actually talking about using programming
    tools to solve problems. Before solving the problem, we need to model the problem
    first. Traditionally, we usually figured out an algorithm that takes several steps
    to solve a numeric computing problem. Then, we wrote some procedural code to implement
    the algorithm. For example, most statistical algorithms are implemented in a procedural
    style, that is, by transforming the input into the output according to the theory,
    step by step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论编程时，我们实际上是在谈论使用编程工具来解决问题。在解决问题之前，我们需要首先对问题进行建模。传统上，我们通常找出一个需要几个步骤来解决数值计算问题的算法。然后，我们编写一些过程式代码来实现该算法。例如，大多数统计算法都是以过程式风格实现的，也就是说，根据理论将输入转换为输出，一步一步地。
- en: However, many problems are so closely bounded to the real world that it can
    be very intuitive to model the problem by defining some classes of objects as
    well as the interaction between them. In other words, by programming in an object-oriented
    style, we simply try to mimic the important features of the objects in concern
    at an appropriate level of abstraction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多问题与现实世界紧密相连，以至于通过定义一些对象类以及它们之间的交互来建模问题可能非常直观。换句话说，通过面向对象的编程方式，我们只是试图在适当的抽象级别上模拟相关对象的重要特征。
- en: There are many concepts involved in object-oriented programming. Here, we will
    only focus on the most important ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程涉及许多概念。在这里，我们只关注其中最重要的。
- en: Understanding classes and methods
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解类和方法
- en: The most important concepts in this chapter are classes and methods. A class
    describes what the object is, and a method defines what it can do. There are countless
    real-world examples for these concepts. For example, `animal` can be a class.
    In this class, we can define methods such as make sound and move. The `vehicle`
    can be a class, too. In this class, we can define methods such as start, move,
    and stop. The `person` can be a class that has methods such as wake up, talk to
    another person, and go somewhere.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的概念是类和方法。类描述了对象是什么，方法定义了它能够做什么。这些概念在现实世界中有着无数的实际例子。例如，`animal` 可以是一个类。在这个类中，我们可以定义诸如发出声音和移动等方法。`vehicle`
    也可以是一个类。在这个类中，我们可以定义诸如启动、移动和停止等方法。`person` 可以是一个具有诸如醒来、与人交谈和去某个地方等方法的类。
- en: For a particular problem, we can define classes according to our need to model
    the objects we are dealing with and define methods for them to model the interaction
    between the objects. The objects need not be physical or tangible. One practical
    example is a bank account. It only exists in the data storage of banks, but it
    can be useful to model bank accounts with some data fields such as balance and
    owner, and some methods such as deposit, withdraw, and transfer between two accounts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的问题，我们可以根据我们的需求定义类来模拟我们正在处理的对象，并为它们定义方法来模拟对象之间的交互。对象不需要是物理的或可触摸的。一个实际的例子是银行账户。它只存在于银行的数据库中，但使用一些数据字段（如余额和所有者）和一些方法（如存款、取款和账户间转账）来模拟银行账户是有用的。
- en: Understanding inheritance
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解继承
- en: Another important concept of object-oriented programming is inheritance, that
    is, we can define a class that inherits the behavior of a base (or super) class
    and has some new behavior. Usually, the base class is more abstract and general
    in concept, and the inheriting class is more concrete and specific. This is simply
    true for the concepts in our everyday life.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的另一个重要概念是继承，即我们可以定义一个继承自基类（或超类）行为的类，并具有一些新的行为。通常，基类在概念上更抽象和通用，而继承类更具体和特定。这在我们的日常生活中是一个简单的真理。
- en: For example, `dog` and `cat` are two classes that inherit from the `animal`
    class. The `animal` class defines methods such as make sound and move. The `dog`
    and `cat` classes inherit these methods but implement them in different ways so
    that they make different sounds and move in different manners.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`dog` 和 `cat` 是从 `animal` 类继承的两个类。`animal` 类定义了诸如发出声音和移动等方法。`dog` 和 `cat`
    类继承了这些方法，但以不同的方式实现，以便它们发出不同的声音并以不同的方式移动。
- en: Also, `car`, `bus`, and `airplane` are classes that inherit from the `vehicle`
    class. The `vehicle` class defines methods such as `start`, `move`, and `stop`.
    The `car`, `bus`, and `airplane` classes inherit these functionalities but work
    in different ways. The `car` and `bus` can move in two dimensions on the surface,
    while airplane can move in three dimensions in the air.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`car`、`bus` 和 `airplane` 是从 `vehicle` 类继承的类。`vehicle` 类定义了诸如 `start`、`move`
    和 `stop` 等方法。`car`、`bus` 和 `airplane` 类继承了这些功能，但以不同的方式工作。`car` 和 `bus` 可以在表面上以二维方式移动，而飞机可以在空中以三维方式移动。
- en: There are some other concepts in the system of object-oriented programming,
    but we are not going to focus on them in this chapter. Let's keep in mind the
    concepts we mentioned and see how these concepts work in R programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程系统中还有一些其他概念，但在这章中我们不会对它们进行重点讨论。让我们记住我们提到的概念，并看看这些概念在 R 编程中的工作方式。
- en: Working with the S3 object system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 S3 对象系统一起工作
- en: The S3 object system in R is a simple, loose, object-oriented system. Every
    basic object type has an S3 class name. For example, `integer`, `numeric`, `character`, `logical`, `list`,
     `data.frame`, and so on are all S3 classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的 S3 对象系统是一个简单、松散的面向对象系统。每个基本对象类型都有一个 S3 类名。例如，`integer`、`numeric`、`character`、`logical`、`list`、`data.frame`
    等都是 S3 类。
- en: 'For example, the type of `vec1` class is `double`, which means the internal
    type or storage mode of `vec1` is double floating numbers. However, its S3 class
    is `numeric`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`vec1` 类型的类型是 `double`，这意味着 `vec1` 的内部类型或存储模式是双精度浮点数。然而，它的 S3 类是 `numeric`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The type of `data1` class is `list`, which means the internal type or storage
    mode of `data1` is a list, but its S3 class is `data.frame`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`data1` 类型的类型是 `list`，这意味着 `data1` 的内部类型或存储模式是一个列表，但它的 S3 类是 `data.frame`：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the following sections, we'll explain the difference between the internal
    type of an object and its S3 class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将解释对象内部类型与其 S3 类之间的区别。
- en: Understanding generic functions and method dispatch
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解泛型函数和方法调度
- en: As we mentioned earlier in this chapter, a class can possess a number of methods
    that define its behavior, mostly with other objects. In the S3 system, we can
    create generic functions and implement them for different classes as methods.
    This is how the S3 method dispatch works to make the class of an object important.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，一个类可以拥有许多方法来定义其行为，主要是与其他对象一起。在S3系统中，我们可以创建泛型函数并为不同的类实现它们作为方法。这就是S3方法调度如何使对象类变得重要的。
- en: There are many simple examples of the S3 generic function in R. Each of them
    is defined for a general purpose and allows different classes of objects to have
    their own implementation for that purpose. Let's first take a look at the `head()`
    and `tail()` functions. Their functionality is simple: `head()` gets the first `n`
    records of a data object, while `tail()` gets the last `n` records of a data object.
    It is different from`x[1:n]` because it has different definitions of record for
    different classes of objects. For an atomic vector (numeric, character, and so
    on), the first `n` records just means the first `n` elements. However, for a data
    frame, the first `n` record means the first `n` rows rather than columns. Since
    a data frame is essentially a list, directly taking out the first `n` elements
    from a data frame is actually taking out the first `n` columns, which is not what `head()`
    is intended for.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: R中有很多S3泛型函数的简单例子。每个都是为通用目的定义的，允许不同类的对象为该目的有自己的实现。让我们首先看看`head()`和`tail()`函数。它们的功能很简单：`head()`获取数据对象的前`n`条记录，而`tail()`获取数据对象的后`n`条记录。它与`x[1:n]`不同，因为它为不同类的对象定义了不同的记录。对于一个原子向量（数值、字符等），前`n`条记录仅意味着前`n`个元素。然而，对于一个数据框，前`n`条记录意味着前`n`行而不是列。因为数据框本质上是一个列表，直接从数据框中取出前`n`个元素实际上是取出前`n`列，这不是`head()`的意图。
- en: 'First, let''s type `head` and see what''s inside the function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们输入`head`并看看函数内部有什么内容：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We find that there are no actual implementation details in this function. Instead,
    it calls `UseMethod("head")` to make `head` a so-called **generic function** to
    perform method dispatch, that is, it may behave in different ways for different
    classes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这个函数中没有任何实际的实现细节。相反，它调用`UseMethod("head")`使`head`成为一个所谓的**泛型函数**以执行方法调度，即它可能对不同的类有不同的行为。
- en: 'Now, let''s create two data objects of `numeric` class and `data.frame` class,
    respectively, and see how method dispatch works when we pass each object to the
    generic function `head`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个数据对象，一个是`numeric`类，另一个是`data.frame`类，然后看看当我们把每个对象传递给泛型函数`head`时，方法调度是如何工作的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For a numeric vector, `head` simply takes its first several elements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值向量，`head`简单地取其前几个元素。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, for a data frame, `head` takes its first several rows rather than
    columns:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于数据框，`head`取其前几行而不是列：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can use a function to mimic the behavior of `head`. The following
    code is a simple implementation that takes the first `n` elements of any given
    object `x`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以使用一个函数来模拟`head`的行为。以下代码是一个简单的实现，它取任何给定对象`x`的前`n`个元素：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For a numeric vector, it works in exactly the same way as `head`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值向量，它的工作方式与`head`完全相同：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, for a data frame, it actually tries to take out the first `n` columns.
    Recall that the data frame is a list, and each column of the data frame is an
    element of the list. It may cause an error if `n` exceeds the number of columns
    of the data frame or, equivalently, the number of elements of the list:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于数据框，它实际上试图取出前`n`列。回想一下，数据框是一个列表，数据框的每一列都是列表的一个元素。如果`n`超过了数据框的列数或等价地列表的元素数，可能会出错：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To improve the implementation, we can check whether the input object `x` is
    a data frame before taking any measures:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进实现，我们可以在采取任何措施之前检查输入对象`x`是否是数据框：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the behavior of `simple_head2` is almost the same with `head` for atomic
    vectors and data frames:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于原子向量和数据框，`simple_head2`的行为几乎与`head`相同：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, `head` offers more than this. To see the methods implemented for `head`,
    we can call `methods()`, which returns a character vector:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`head`提供了更多功能。要查看为`head`实现的函数，我们可以调用`methods()`，它返回一个字符向量：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It shows that there is already a bunch of built-in methods of `head` for a number
    of classes other than vectors and data frames. Note that the methods are all in
    the form of `method.class`. If we input a `data.frame` object, `head` will call `head.data.frame`
    internally. Similarly, if we input a `table` object, it will call `head.table`
    internally. What if we input a numeric vector? When no method is found that matches
    the class of the input object, it will turn to `method.default`, if defined. In
    this case, all atomic vectors are matched by `head.default`. The process through
    which a generic function finds the appropriate method for a certain input object
    is called **method dispatch**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明除了向量和数据框之外，`head` 已经为许多其他类提供了一些内置方法。请注意，这些方法都是以 `method.class` 的形式存在的。如果我们输入一个
    `data.frame` 对象，`head` 将内部调用 `head.data.frame`。同样，如果我们输入一个 `table` 对象，它将内部调用 `head.table`。如果我们输入一个数值向量呢？当找不到与输入对象类匹配的方法时，如果定义了
    `method.default`，它将转向 `method.default`。在这种情况下，所有原子向量都通过 `head.default` 匹配。泛型函数找到特定输入对象适当方法的这个过程称为
    **方法调度**。
- en: It looks like we can always check the class of the input object in a function
    to achieve the goal of method dispatch. However, it is easier to implement a method
    for another class to extend the functionality of a generic function because you
    don't have to modify the original generic function by adding specific class-checking
    conditions each time. We'll cover this later in this section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们可以在函数中始终检查输入对象的类以实现方法调度的目标。然而，为另一个类实现方法以扩展泛型函数的功能更容易，因为你不必每次都通过添加特定的类检查条件来修改原始的泛型函数。我们将在本节稍后讨论这一点。
- en: Working with built-in classes and methods
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置类和方法
- en: 'S3 generic functions and methods are most useful in unifying the way we work
    with all kinds of models. For example, we can create a linear model and use generic
    functions to view the model from different perspectives:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: S3 泛型函数和方法在统一我们处理各种模型的方式上最有用。例如，我们可以创建一个线性模型，并使用泛型函数从不同的角度查看模型：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In previous chapters, we mentioned that a linear model is essentially a list
    of data fields resulted from model fitting. That''s why the type of `lm1` is `list`,
    but its class is `lm` so that generic functions will choose methods for `lm`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到线性模型本质上是由模型拟合产生的数据字段的列表。这就是为什么 `lm1` 的类型是 `list`，但它的类是 `lm`，这样泛型函数就会为
    `lm` 选择方法：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The S3 method dispatch even happens without explicit calling of S3 generic
    functions. If we type `lm1` and see what it is, the model object is printed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: S3 方法调度甚至在没有显式调用 S3 泛型函数的情况下发生。如果我们输入 `lm1` 并查看其内容，模型对象将被打印出来：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In fact, `print` is implicitly called:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`print` 是隐式调用的：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We know that `lm1` is essentially a list. Why does it not look like a list
    when it is printed? This is because `print` is a generic function, and it has
    a method for `lm` that prints the most important information of the linear model.
    We can get the actual method we call by `getS3method("print", "lm")`. In fact, `print(lm1)`
    goes to `stats:::print.lm`, which can be verified by checking whether they are
    identical:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `lm1` 本质上是一个列表。为什么打印时它看起来不像一个列表？这是因为 `print` 是一个泛型函数，它有一个为 `lm` 打印线性模型最重要信息的
    `lm` 方法。我们可以通过 `getS3method("print", "lm")` 获取我们实际调用的方法。实际上，`print(lm1)` 转向 `stats:::print.lm`，这可以通过检查它们是否相同来验证：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that `print.lm` is defined in the `stats` package, but is not exported
    for public use, so we have to use `:::` to access it. Generally, it is a bad idea
    to access internal objects in a package, because they may change in different
    releases and have no changes visible to the user. In most cases, we simply don't
    need to because generic functions such as `print` automatically choose the right
    method to call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`print.lm` 定义在 `stats` 包中，但并未公开导出，因此我们必须使用 `:::` 来访问它。通常，访问包中的内部对象是一个坏主意，因为它们可能在不同的版本中发生变化，并且用户看不到这些变化。在大多数情况下，我们根本不需要这样做，因为像
    `print` 这样的泛型函数会自动选择正确的调用方法。
- en: 'In R, `print` has methods implemented for many classes. The following code
    shows how many methods are implemented for different classes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，`print` 方法为许多类实现了。以下代码展示了为不同类实现了多少种方法：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can call `methods("print")` to view the whole list. In fact, if more packages
    are loaded, there will be more methods defined for classes in these packages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用 `methods("print")` 来查看整个列表。实际上，如果加载了更多的包，这些包中的类将定义更多的方法。
- en: 'While `print` shows a brief version of the model, `summary` shows detailed
    information. This function is also a generic function that has many methods for
    all kinds of model classes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`print`显示了模型的简短版本，但`summary`显示了详细的信息。此函数也是一个泛型函数，它为所有类型的模型类提供了许多方法：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The summary of a linear model provides not only what `print` shows but also
    some important statistics for the coefficients and the overall model. In fact,
    the output of `summary` is another object that can be accessed for the data it
    contains. In this case, it is a list of the `summary.lm` class, and it has its
    own method of `print`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型的总结不仅显示了`print`显示的内容，还提供了系数和整体模型的一些重要统计数据。实际上，`summary`的输出是另一个可以访问其包含数据的对象。在这种情况下，它是一个`summary.lm`类的列表，并且它有自己的`print`方法：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To list what elements `lm1summary` contains, we can view the names on the list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出`lm1summary`包含的元素，我们可以查看列表中的名称：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can access each element in exactly the same way as we extract an element
    from a typical list. For example, to access the estimated coefficients of the
    linear model, we can use `lm1$coefficients`. Alternatively, we will use the following
    code to access the estimated coefficients:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以完全相同的方式访问每个元素，就像从典型的列表中提取元素一样。例如，要访问线性模型的估计系数，我们可以使用`lm1$coefficients`。或者，我们可以使用以下代码来访问估计系数：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, `coef` is also a generic function that extracts the vector of coefficients
    from a model object. To access the detailed coefficient table in the model summary,
    we can use `lm1summary$coefficients` or, again, `coef`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`coef`也是一个泛型函数，它从模型对象中提取系数向量。要访问模型总结中的详细系数表，我们可以使用`lm1summary$coefficients`或再次使用`coef`：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are other useful model-related generic functions such as `plot`, `predict`,
    and so on. All these generic functions we mentioned are standard ways in R for
    users to interact with an estimated model. Different built-in models and those
    provided by third-party packages all try to implement these generic functions
    so that we don't need to remember different sets of functions to work with each
    model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他有用的模型相关泛型函数，如`plot`、`predict`等。我们提到的所有这些泛型函数都是R中用户与估计模型交互的标准方式。不同的内置模型和第三方包提供的模型都试图实现这些泛型函数，这样我们就不需要记住不同的函数集来处理每个模型。
- en: 'For example, we can use the `plot` function to the linear model with 2-by-2
    partitions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`plot`函数对线性模型进行2x2分区：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This produces the following image with four parts:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下包含四个部分的图像：
- en: '![Working with built-in classes and methods](img/image_10_001.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置类和方法](img/image_10_001.jpg)'
- en: We can see that we used `plot` function to a linear model, which will result
    in four diagnostic plots that show the features of the residuals, which can be
    helpful in getting an impression on whether the model fit is good or bad. Note
    that if we directly call the `plot` function to a `lm` in a console, the four
    plots are interactively done in turn. To avoid this, we call `par()` to divide
    the plot area into 2-by-2 subareas.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们使用了`plot`函数对线性模型进行操作，这将导致四个诊断图，显示残差的特征，这有助于判断模型拟合是好是坏。注意，如果我们直接在控制台中调用`plot`函数到`lm`，四个图将依次交互式完成。为了避免这种情况，我们调用`par()`将绘图区域划分为2x2的子区域。
- en: 'Most statistical models are useful because they can be used to predict with
    new data. To do this, we use `predict`. In this case, we can supply the linear
    model and the new data to `predict`, and it will find the right method to make
    predictions with new data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数统计模型都是有用的，因为它们可以用新数据来预测。为此，我们使用`predict`。在这种情况下，我们可以将线性模型和新数据提供给`predict`，它将找到使用新数据进行预测的正确方法：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function can be used both in sample and out of sample. If we supply new
    data to the model, it is out-of-sample prediction. If the data we supply is already
    in the sample, it is in-sample prediction. Here, we can create a scatter plot
    between actual values `(mtcars$mpg)` and fitted values to see how well the fitted
    linear model predicts:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以在样本内和样本外使用。如果我们向模型提供新数据，则是样本外预测。如果我们提供的数据已经在样本中，则是样本内预测。在这里，我们可以创建实际值`(mtcars$mpg)`和拟合值之间的散点图，以查看拟合的线性模型预测得有多好：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The plot generated is shown as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图如下所示：
- en: '![Working with built-in classes and methods](img/image_10_002.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置类和方法](img/image_10_002.jpg)'
- en: Here, `fitted` is also a generic function, which, in this case, is equivalent
    to `lm1$fitted.values`, fitted values are also equal to the predicted values with
    the original dataset using `predict(lm1, mtcars)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fitted` 也是一个泛型函数，在这种情况下，它等同于 `lm1$fitted.values`，拟合值也等于使用 `predict(lm1,
    mtcars)` 在原始数据集上预测的值。
- en: 'The difference between the actual values and fitted values of the response
    variable is called residuals. We can use another generic function `residuals`
    to access the numeric vector, or equivalently, use `lm1$residuals`. Here, we will
    make a density plot of the residuals:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 响应变量的实际值与拟合值之间的差异称为残差。我们可以使用另一个泛型函数 `residuals` 来访问数值向量，或者等价地使用 `lm1$residuals`。在这里，我们将对残差进行密度图绘制：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The plot generated is shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图如下所示：
- en: '![Working with built-in classes and methods](img/image_10_003.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置类和方法](img/image_10_003.jpg)'
- en: In the preceding function call, all involved functions are generic functions.
    The `residuals` function extracts the residuals from `lm1` and returns a numeric
    vector. The `density` function creates a list of class `density` to store the
    estimated data of density function of the residuals. Finally, `plot` turns to `plot.density`
    to create a density plot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数调用中，所有涉及到的函数都是泛型函数。`residuals` 函数从 `lm1` 中提取残差并返回一个数值向量。`density` 函数创建一个类为
    `density` 的列表来存储残差密度函数的估计数据。最后，`plot` 转换为 `plot.density` 来创建密度图。
- en: These generic functions work not only with `lm`, `glm`, and other built-in models,
    but also with models provided by other packages. For example, we use the `rpart`
    package to fit a regression tree model using the same data and the same formula
    in the previous example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些泛型函数不仅与 `lm`、`glm` 和其他内置模型一起工作，还与其他包提供的模型一起工作。例如，我们使用 `rpart` 包使用与前面例子中相同的数据和公式来拟合回归树模型。
- en: 'If you don''t have the package installed, you need run the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装该包，你需要运行以下代码：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the package is ready to attach. We call `rpart` in exactly the same way
    as `lm`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，包已经准备好附加。我们以与 `lm` 完全相同的方式调用 `rpart`：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can do so because the package authors want the function call to be consistent
    with how we call built-in functions in R. The resulted object is a list of class
    `rpart`, which works in the same way with `lm` is a list of class `rpart`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能够这样做，是因为包的作者希望函数调用与我们在 R 中调用内置函数的方式保持一致。结果对象是一个类为 `rpart` 的列表，它与 `lm`
    类似，也是一个类为 `rpart` 的列表：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Like `lm` object, `rpart` also has a number of generic methods implemented.
    For example, we use the `print` function to print the model in its own way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `lm` 对象一样，`rpart` 也实现了一系列泛型方法。例如，我们使用 `print` 函数以自己的方式打印模型：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output indicates that `print` has a method for `rpart`, which briefly shows
    what the regression tree looks like. In addition to `print`, `summary` gives more
    detailed information about the model fitting:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明 `print` 为 `rpart` 提供了方法，它简要地显示了回归树的外观。除了 `print` 之外，`summary` 还提供了关于模型拟合的更详细信息：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Likewise, `plot` and `text` also have methods for `rpart` to visualize it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`plot` 和 `text` 也为 `rpart` 提供了方法来可视化它：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we have the following tree graph:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到以下树状图：
- en: '![Working with built-in classes and methods](img/image_10_004.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置类和方法](img/image_10_004.jpg)'
- en: 'We can use `predict` to make predictions with new data, just like what we did
    with the linear model in the previous examples:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `predict` 使用新数据进行预测，就像我们在前面的例子中处理线性模型一样：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that not all models implement methods for all the generic functions. For
    example, since the regression tree is not a simple parametric model, it does not
    implement a method for `coef`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有模型都实现了所有泛型函数的方法。例如，由于回归树不是一个简单的参数模型，它没有实现 `coef` 的方法：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Defining generic functions for existing classes
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为现有类定义泛型函数
- en: In the previous section, you learned how to use existing classes and methods
    to work with model objects. The S3 system, however, also allows us to create our
    own classes and generic functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何使用现有类和方法来处理模型对象。然而，S3 系统还允许我们创建自己的类和泛型函数。
- en: 'Recall the example where we used conditional expressions to mimic the method
    dispatch of `head`. We mentioned that it works, but is often not the best practice.
    S3 generic functions are more flexible and easier to extend. To define a generic
    function, we usually create a function in which  `UseMethod` is called to trigger
    method dispatch. Then, we create method functions in the form of `method.class`
    for the classes we want the generic function to work with and usually a default
    method in the form of `method.default` to capture all other cases. Here is a simple
    rewriting of this example using generic function and methods. Here, we will create
    a new generic function, `generic_head`, with two arguments: the input object `x`
    and the number of records to take, `n`. The generic function only calls `UseMethod("generic_head")`
    to ask R for method dispatch according to the class of `x`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们使用条件表达式来模拟`head`的方法调度示例。我们提到它工作，但通常不是最佳实践。S3通用函数更灵活且更容易扩展。要定义一个通用函数，我们通常创建一个函数，在其中调用`UseMethod`来触发方法调度。然后，我们为想要通用函数与之一起工作的类创建形式为`method.class`的方法函数，通常还有一个形式为`method.default`的默认方法来捕获所有其他情况。以下是使用通用函数和方法重写此示例的简单示例。在这里，我们将创建一个新的通用函数`generic_head`，它有两个参数：输入对象`x`和要取的记录数`n`。通用函数只调用`UseMethod("generic_head")`来请求R根据`x`的类进行方法调度：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For atomic vectors (numeric, character, logical, and so on), the first `n`
    elements should be taken. We can define `generic_head.numeric`, `generic_head.character`,
    and so on respectively, but in this case, it looks better to define a default
    method to capture all cases that are not matched by other `generic_head.class`
    methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原子向量（数值、字符、逻辑等），应该取前`n`个元素。我们可以分别定义`generic_head.numeric`、`generic_head.character`等，但在这种情况下，定义一个默认方法来捕获所有其他`generic_head.class`方法未匹配的案例看起来更好：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, `generic_head` has only one method, which is equivalent to not using generic
    function at all:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`generic_head`只有一个方法，这相当于根本不使用通用函数：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since we haven''t defined the method for class `data.frame`, supplying a data
    frame will fall back to `generic_head.default`, which causes an error due to the
    invalid access of an out-of-bound column index:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为`data.frame`类定义方法，提供数据框将回退到`generic_head.default`，这会导致由于越界列索引的无效访问而引发错误：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, let''s assume we define a method for `data.frame`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们为`data.frame`定义了一个方法：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The generic function works as it is supposed to:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数按预期工作：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may notice that the methods we implemented earlier are not robust because
    we don't have the argument checked. For example, if `n` is greater than the number
    of elements of the input object, the function will behave differently and usually
    in an undesirable way. I'll leave it as an exercise for you to make the methods
    more robust and behave appropriately for corner cases.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们之前实现的方法不够健壮，因为我们没有检查参数。例如，如果`n`大于输入对象的元素数量，函数的行为将不同，通常是不希望的方式。我将把它留给你作为练习，使方法更健壮，并适当地处理边缘情况。
- en: Creating objects of new classes
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新类的对象
- en: Now, it is time to have some examples of defining new classes. Note that `class(x)`
    gets the class of `x`, while `class(x) <- "some_class"` sets the class of `x`
    to `some_class`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候给出一些定义新类的示例了。请注意，`class(x)`获取`x`的类，而`class(x) <- "some_class"`将`x`的类设置为`some_class`。
- en: Using list as the underlying data structure
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表作为底层数据结构
- en: Just like `lm` and `rpart`, list is probably the most widely used underlying
    data structure to create a new class. This is because a class represents a type
    of object that can store different kinds of data with different lengths and has
    some methods to interact with other objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`lm`和`rpart`一样，列表可能是创建新类最广泛使用的底层数据结构。这是因为一个类代表一种可以存储不同类型数据且长度不同的对象类型，并且有一些方法可以与其他对象交互。
- en: 'In the following example, we will define a function called `product` that creates
    a list of the class `product` with a name, price, and inventory. We''ll define
    its own `print` method and add more behaviors as we go ahead:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将定义一个名为`product`的函数，它创建一个具有名称、价格和库存的`product`类列表。我们将定义它自己的`print`方法，并在继续的过程中添加更多行为：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that we created a list first, replaced its class with `product`, and finally
    returned the object. In fact, the class of an object is a character vector. An
    alternative way is to use `structure()`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先创建了一个列表，将其类替换为`product`，然后最终返回对象。实际上，对象的类是一个字符向量。另一种方法是使用`structure()`：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we have a function that produced objects of the class `product`. In the
    following code, we will call `product()` and create an instance of this class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个生成`product`类对象的函数。在下面的代码中，我们将调用`product()`并创建这个类的实例：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like all previous objects, we can see its internal data structure and its S3
    class for method dispatch:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有之前的对象一样，我们可以看到它的内部数据结构和它的S3类以进行方法调度：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Obviously, `laptop` is a list of class `product` as we created it. Since we
    haven''t defined any methods for this class, its behavior is no different from
    an ordinary list object. If we type it, it will be printed as a list with its
    customized class attribute:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`laptop`是一个类`product`的列表，正如我们创建的那样。由于我们没有为这个类定义任何方法，它的行为与普通列表对象没有区别。如果我们输入它，它将以列表的形式打印出来，并带有其自定义的类属性：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we can implement the `print` method for this class. Here, we want the
    class and the data fields in it to be printed in a compact style:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以为这个类实现`print`方法。在这里，我们希望类及其中的数据字段以紧凑的样式打印出来：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It is a convention that the `print` method returns the input object itself for
    further use. If the printing is customized, then we often use `invisible` to suppress
    repeated printing of the same object that the function returns. You may try returning `x`
    directly and see what happens.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个惯例，`print`方法返回输入对象本身以供进一步使用。如果打印被定制，那么我们通常使用`invisible`来抑制函数返回的相同对象的重复打印。你可以尝试直接返回`x`并看看会发生什么。
- en: 'Then, we type the variable again. The `print` method will be dispatched to `print.product`
    since it is already defined:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次输入变量。由于`print`方法已经被定义，它将被调度到`print.product`。
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can access the elements in `laptop` just like extracting elements from a
    list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像从列表中提取元素一样访问`laptop`中的元素：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we create another instance and put the two instances into a list, `print.product`
    will still be called when the list is printed:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建另一个实例并将这两个实例放入一个列表中，当列表被打印时，`print.product`仍然会被调用：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is because when `products` is printed as a list, it calls `print` on each
    of the elements, which also causes method dispatch.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当`products`作为列表打印时，它会为每个元素调用`print`，这也会导致方法调度。
- en: Creating an S3 class is much simpler than most other programming languages that
    require formal definition of classes. It is important to have sufficient checking
    on the arguments to ensure that the created object is internally consistent with
    what the class represents.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建S3类比大多数需要正式定义类的编程语言要简单得多。对参数进行充分的检查以确保创建的对象在内部与类所表示的内容一致是很重要的。
- en: 'For example, without proper checking, we can create a product with negative
    and non-integer inventory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果没有适当的检查，我们可以创建一个具有负数和非整数的库存的产品：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To avoid this, we need to add some checking conditions in the object-generating
    function, `product`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们需要在对象生成函数`product`中添加一些检查条件：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The function is enhanced, in that `name` must be a single string, `price` must
    be a single positive number, and `inventory` must be a single non-negative number.
    With this function, we cannot create ridiculous products by mistake, and such
    errors can be found in an early stage:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数得到了增强，其中`name`必须是一个单独的字符串，`price`必须是一个单独的正数，而`inventory`必须是一个单独的非负数。有了这个函数，我们不会错误地创建荒谬的产品，并且这样的错误可以在早期被发现：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In addition to defining new classes, we can also define new generic functions.
    In the following code, we will define a new generic function called `value` and
    implement a method for `product` by measuring the value of the inventory of the
    product:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义新的类，我们还可以定义新的泛型函数。在下面的代码中，我们将定义一个新的泛型函数，称为`value`，并通过测量产品的库存值来实现`product`的方法：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For other classes, it calls `value.default` and stops. Now, `value` can be
    used with all instances of `product` we created:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类，它调用`value.default`并停止。现在，`value`可以与所有我们创建的`product`实例一起使用：
- en: '[PRE54]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The generic function also works with apply family functions by performing method
    dispatch for each element in the input vector or list:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数还可以通过为输入向量或列表中的每个元素执行方法调度与apply家族函数一起工作：
- en: '[PRE55]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'One more question is once we create the object of a certain class, does that
    mean that we can no longer change it? No, we still can change it. In this case,
    we can modify an existing element of `laptop`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是一旦我们创建了一个特定类的对象，这意味着我们不能再改变它了吗？不，我们仍然可以改变它。在这种情况下，我们可以修改`laptop`中现有的元素：
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also create a new element in `laptop`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`laptop`中创建一个新的元素：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can take a look at it, and the changes are effective:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看它，并且更改是有效的：
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: What's worse is that we can even remove an element by setting it to `NULL`.
    This is why the S3 system is considered to be loose. You can't make sure that
    the object of a certain type has a fixed set of data fields and methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，我们甚至可以通过将其设置为 `NULL` 来删除一个元素。这就是为什么 S3 系统被认为比较宽松。你不能确保特定类型的对象具有一组固定的数据字段和方法。
- en: Using an atomic vector as the underlying data structure
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原子向量作为底层数据结构
- en: In the previous section, we demonstrated an example of creating a new class
    from a list object. In fact, it is sometimes useful to create a new class of object
    from an atomic vector. In this section, I will show you a series of steps to create
    vectors with a percentage representation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们演示了从列表对象创建新类的示例。实际上，有时从原子向量创建新类对象也是有用的。在本节中，我将向您展示一系列创建具有百分比表示的向量的步骤。
- en: 'We first define a function, `percent`. This function simply checks whether
    the input is a numeric vector and alters its class to `percent`, which inherits
    from `numeric`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，`percent`。这个函数简单地检查输入是否为数值向量，并将其类更改为 `percent`，它继承自 `numeric`：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The inheritance here means that method dispatch first looks for methods of `percent`.
    If none is found, then it looks for methods of `numeric`. Therefore, the order
    of the class names matters. S3 inheritance will be covered in detail in the following
    section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的继承意味着方法调度首先寻找 `percent` 的方法。如果没有找到，那么它将寻找 `numeric` 的方法。因此，类名的顺序很重要。S3 继承将在下一节中详细讨论。
- en: 'Now, we can create a percent vector from a numeric vector:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从数值向量创建一个百分比向量：
- en: '[PRE60]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: At the moment, there is no method implemented for `percent`. So, `pct` looks
    like an ordinary numeric vector with a customized class attribute. The purpose
    of this class is to show its values in percentage form, such as 25 percent instead
    of its original decimal representation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尚未实现 `percent` 的方法。因此，`pct` 看起来像是一个具有自定义类属性的普通数值向量。这个类的作用是显示其值的百分比形式，例如 25%，而不是其原始的十进制表示。
- en: 'To achieve this goal, we first implement `as.character` for the `percent` class
    by producing the correct string representation of the percentage form:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们首先为 `percent` 类实现 `as.character`，生成正确的百分比形式的字符串表示：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we can get the desired string representation of a given percent vector:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以得到给定百分比向量的所需字符串表示：
- en: '[PRE62]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Likewise, we need to implement `format` for `percent` by directly calling `as.character`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要通过直接调用 `as.character` 来为 `percent` 实现 `format`：
- en: '[PRE63]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, `format` has the same effect:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`format` 有相同的效果：
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can implement `print` for `percent` by calling `format.percent` directly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过直接调用 `format.percent` 来为 `percent` 实现 `print`：
- en: '[PRE65]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that we specify `quote = FALSE` when we print the formatted strings to
    make it look like numbers rather than strings. This is exactly the desired effect:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们打印格式化的字符串时，我们指定 `quote = FALSE`，使其看起来像数字而不是字符串。这正是我们想要的效果：
- en: '[PRE66]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note that arithmetic operators such as `+` and `*` automatically preserve the
    class of the output vector. As a result, the output vector is still printed in
    percentage form:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，算术运算符如 `+` 和 `*` 会自动保留输出向量的类。因此，输出向量仍然以百分比形式打印：
- en: '[PRE67]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Unfortunately, other functions may not preserve the class of their input. For
    example, `sum`, `mean`, `max`, and `min` will drop the customized class and return
    a plain numeric vector instead:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，其他函数可能不会保留其输入的类。例如，`sum`、`mean`、`max` 和 `min` 将丢弃自定义类，并返回一个普通的数值向量：
- en: '[PRE68]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To make sure the percentage form is preserved when we perform these calculations,
    we need to implement these methods for the `percent` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在执行这些计算时百分比形式得到保留，我们需要为 `percent` 类实现这些方法：
- en: '[PRE69]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the first method, `NextMethod("sum")` calls `sum` for numeric class, and
    the output numeric vector is wrapped with `percent` again. The same logic also
    applies to the implementation of the other three methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方法中，`NextMethod("sum")` 调用数值类的 `sum`，并将输出数值向量再次包裹在 `percent` 中。同样的逻辑也适用于其他三个方法的实现：
- en: '[PRE70]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, these functions return values in percentage form, too. However, if we
    combine a percent vector with other numeric values, the percent class will be
    gone:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些函数也以百分比形式返回值。然而，如果我们将百分比向量与其他数值值结合，百分比类就会消失：
- en: '[PRE71]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can do the same thing to `c`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对 `c` 做同样的事情：
- en: '[PRE72]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, combining percent vectors with numeric values result in percent vectors
    too:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将百分比向量与数值值结合也会产生百分比向量：
- en: '[PRE73]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'However, from the other side, when we subset the percent vector or extract
    a value from it, the percent class will be dropped:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从另一方面来看，当我们对百分比向量进行子集操作或从中提取值时，百分比类将被丢弃：
- en: '[PRE74]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To fix this, we need to implement `[` and `[[` for `percent` in exactly the
    same way. You might be surprised to see a method called `[.percent`, but it will
    indeed match the `percent` class when we use these operators on a percent vector:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要以完全相同的方式实现`percent`的`[`和`[[`。您可能会惊讶地看到一个名为`[.percent`的方法，但当我们使用这些运算符对百分比向量进行操作时，它确实会匹配`percent`类：
- en: '[PRE75]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, both subsetting and extracting preserve the percent class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，子集和提取都保留了百分比类：
- en: '[PRE76]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'With all these methods implemented, we can place a percent vector as a column
    of a data frame:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现所有这些方法之后，我们可以将百分比向量作为数据框的列放置：
- en: '[PRE77]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The percentage form is correctly preserved as a column in the data frame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比形式正确地保留为数据框中的列。
- en: Understanding S3 inheritance
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解S3继承
- en: The S3 system is loose. You only need to create a function in the form of `method.class`
    to implement a method for a generic function. You only need to supply a character
    vector with multiple elements to indicate the inheritance relationship along the
    vector.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: S3系统是宽松的。您只需要创建一个形式为`method.class`的函数来实现泛型函数的方法。您只需要提供一个包含多个元素的字符向量，以指示向量上的继承关系。
- en: As we mentioned in the previous section, the class vector determines the order
    of matching classes in method dispatch. To demonstrate it, we will use a simple
    example in which we construct a number of classes with inheritance relationships.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，类向量决定了方法调度中匹配类的顺序。为了演示这一点，我们将使用一个简单的例子，其中我们将构建具有继承关系的多个类。
- en: Suppose we want to model some vehicles such as a car, bus, and airplane. These
    vehicles have something in common. They all have name, speed, and position, and
    they can move. To model them, we can define a base class called `vehicle`, which
    stores the common parts. We also define `car`, `bus`, and `airplane` that inherit
    from `vehicle` but have customized behaviors.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要模拟一些车辆，如汽车、公交车和飞机。这些车辆有一些共同之处。它们都有名称、速度和位置，并且可以移动。为了模拟它们，我们可以定义一个基类`vehicle`，它存储了共同的部分。我们还定义了继承自`vehicle`的`car`、`bus`和`airplane`，但具有自定义的行为。
- en: 'First, we will define a function to create the `vehicle` object, which is essentially
    an environment. We choose an environment over a list because we need its reference
    semantics, that is, we pass around the object, and modifying it will not cause
    a copy of the object. So, the object always refers to the same vehicle, no matter
    where it is passed around:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个函数来创建`vehicle`对象，这本质上是一个环境。我们选择列表中的环境，因为我们需要它的引用语义，即我们传递对象，修改它不会导致对象的副本。因此，无论在哪里传递，对象始终指向同一辆车：
- en: '[PRE78]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Note that `class(obj) <- c(class, "vehicle")` may look ambiguous because `class`
    is both a function argument and a basic function. In fact, `class(obj) <-` will
    look for the `class<-` function so that the usage does not cause ambiguity. The
    `Vehicle` function is a general creator of vehicle class objects with common data
    fields. The following function is specialized functions to create `car`, `bus`
    and `airplane` that inherit vehicle:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`class(obj) <- c(class, "vehicle")`可能看起来有些模糊，因为`class`既是函数参数也是基本函数。实际上，`class(obj)
    <-`将寻找`class<-`函数，这样使用就不会造成歧义。`Vehicle`函数是一个通用车辆类对象的创建器，具有常见的数据字段。以下是一些专门函数，用于创建继承自`vehicle`的`car`、`bus`和`airplane`：
- en: '[PRE79]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the three preceding functions, we can create `car`, `bus`, and `airplane`
    objects. All inherit from the `vehicle` class. Now, we create an instance for
    each class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个先前的函数的基础上，我们可以创建`car`、`bus`和`airplane`对象。所有这些对象都继承自`vehicle`类。现在，我们为每个类创建一个实例：
- en: '[PRE80]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we will implement a common `print` method for `vehicle`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为`vehicle`实现一个通用的`print`方法：
- en: '[PRE81]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Since no `print.car`, `print.bus` or `print.airplane` is defined, typing those
    variables will print them with `print.vehicle`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有定义`print.car`、`print.bus`或`print.airplane`，输入这些变量将使用`print.vehicle`打印它们：
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A vehicle is a carrier designed to be driven and to move. Naturally, we define
    a generic function called `move`, which modifies the position of a vehicle to
    reflect a user-supplied movement in a three-dimensional space. Since different
    vehicles move in different ways with distinct limitations, we can further implement
    several `move` methods for the various classes of vehicle we just defined:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆是一种设计用来驾驶和移动的载体。自然地，我们定义了一个名为 `move` 的通用函数，该函数修改车辆的位置以反映用户提供的在三维空间中的移动。由于不同的车辆以不同的方式移动，具有不同的限制，因此我们可以为刚刚定义的各种车辆类进一步实现几个
    `move` 方法：
- en: '[PRE83]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, we will limit the movement that can happen to a car and a bus to two
    dimensions. Therefore, we will implement `move.bus` and `move.car` by checking
    the length of the `movement` vector, which is only allowed to be `2`. If the movement
    is valid, then, we would force the third dimension of `movement` to be `0` and
    then call `NextMethod("move")` to call `move.vehicle` with `vehicle` and the latest
    value of `movement`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将限制汽车和公共汽车的移动为二维。因此，我们将通过检查 `movement` 向量的长度来实现 `move.bus` 和 `move.car`，该长度只允许为
    `2`。如果移动有效，那么，我们将强制 `movement` 的第三维为 `0`，然后调用 `NextMethod("move")` 来调用 `move.vehicle`，带有
    `vehicle` 和 `movement` 的最新值：
- en: '[PRE84]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'An airplane can move in either two or three dimensions. Therefore, `move.airplane`
    can be flexible to accept both. If the `movement` vector is two dimensional, then
    the movement on the third dimension is regarded as zero:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 飞机可以在两个或三个维度上移动。因此，`move.airplane` 可以灵活地接受两者。如果 `movement` 向量是二维的，那么第三维度的移动被视为零：
- en: '[PRE85]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'With `move` implemented for all three vehicles, we can test them with the three
    instances. First, let''s see if the following expression goes into an error if
    we want the car to move with a three-dimensional vector:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有三种车辆都实现了 `move`，我们可以用三个实例来测试它们。首先，让我们看看以下表达式是否会产生错误，如果我们想让汽车用三维向量移动：
- en: '[PRE86]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The method dispatch of the preceding function call finds `move.car` and stops
    for the invalid movement. The following code is a two-dimensional movement, which
    is valid:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数调用的方法分派找到 `move.car` 并停止对无效移动的处理。以下代码是二维移动，这是有效的：
- en: '[PRE87]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Similarly, we can move the airplane in two dimensions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在两个维度上移动飞机：
- en: '[PRE88]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can also move it in three dimensions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在三个维度上移动它：
- en: '[PRE89]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that the position of `airplane` is accumulated because it is essentially
    an environment, so modifying `position` in `move.vehicle` does not cause a copy
    of it. Therefore, no matter where you pass it, there is only one instance of it.
    If you are not familiar with the reference semantics of environments, go through [Chapter
    8](ch08.html "Chapter 8. Inside R"), *Inside R*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 `airplane` 实质上是一个环境，其位置是累积的，因此在 `move.vehicle` 中修改 `position` 不会导致它的副本。因此，无论你将它传递到哪里，都只有一个实例。如果你不熟悉环境的引用语义，请参阅[第
    8 章](ch08.html "第 8 章。R 内部")，*R 内部*。
- en: Working with S4
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 S4
- en: In the previous section, we introduced the S3 system. Unlike the object-oriented
    systems in most other programming languages, the S3 system is much less strict
    than a system in which classes are defined with a fixed structure and certain
    method dispatch as the program compiles. When we define an S3 class, almost nothing
    can be sure. We can not only add or remove methods of the class at any time but
    also insert or delete data elements from the object as we wish. In addition, S3
    only supports single dispatch, that is, methods are chosen according to the class
    of only one argument, mostly the first argument.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了 S3 系统。与大多数其他编程语言中的面向对象系统不同，S3 系统比使用固定结构和某些方法分派作为程序编译的系统要宽松得多。当我们定义一个
    S3 类时，几乎没有什么可以确定的。我们不仅可以在任何时候添加或删除类的方法，还可以根据我们的意愿从对象中插入或删除数据元素。此外，S3 只支持单分派，即根据单个参数的类来选择方法，通常是第一个参数。
- en: Then, R introduces a more formal and stricter object-oriented system, S4\. This
    system allows us to define formal classes with pre-specified definition and inheritance
    structure. It also supports multiple dispatch, that is, methods are chosen according
    to the classes of multiple arguments.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，R 引入了一个更正式和更严格的面向对象系统，S4。这个系统允许我们定义具有预先指定定义和继承结构的正式类。它还支持多分派，即根据多个参数的类来选择方法。
- en: In this section, you will learn how to define S4 classes and methods.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何定义 S4 类和方法。
- en: Defining S4 classes
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 S4 类
- en: 'Unlike S3 classes, which are simply represented by character vectors, S4 classes
    require formal definition of classes and methods. To define an S4 class, we need
    to call `setClass` and supply a representation of the class members, which are
    called **slots**. The representation is specified by the name and class of each
    slot. In this section, we''ll redefine the product objects using an S4 class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅由字符向量表示的 S3 类不同，S4 类需要正式定义类和方法。要定义 S4 类，我们需要调用 `setClass` 并提供类成员的表示，这些成员被称为
    **槽位**。表示由每个槽位的名称和类指定。在本节中，我们将使用 S4 类重新定义产品对象：
- en: '[PRE90]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once the class is defined, we can get the slots from its class definition by
    `getSlots()`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了类，我们就可以通过 `getSlots()` 从其类定义中获取槽位：
- en: '[PRE91]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'S4 is stricter than S3, not only because S4 requires class definition, but
    also because R will ensure that the classes of the members that create a new instance
    are consistent with the class representation. Now, we will use `new()` to create
    a new instance of an S4 class and specify the values of the slots:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: S4 比 S3 更严格，不仅因为 S4 需要类定义，而且因为 R 将确保创建新实例的成员类与类表示一致。现在，我们将使用 `new()` 创建 S4 类的新实例并指定槽位的值：
- en: '[PRE92]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It might surprise you that the preceding code produces an error. If you take
    a closer look at the class representation, you will find that `inventory` must
    be an integer. In other words, `100` is a numeric value, which is not of class `integer`.
    It requires `100L` instead:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你惊讶的是，前面的代码会产生错误。如果你仔细查看类表示，你会发现 `inventory` 必须是整数。换句话说，`100` 是一个数值，它不属于
    `integer` 类。它需要 `100L`：
- en: '[PRE93]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now, a new instance of `Product`, `laptop`, is created. It is printed as an
    object of class `Product`. The values of all slots are automatically printed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建了一个新的 `Product` 实例 `laptop`。它被打印为 `Product` 类的对象。所有槽位的值都会自动打印出来。
- en: 'For an S4 object, we can still use `typeof()` and `class()` to get some type
    information:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 S4 对象，我们仍然可以使用 `typeof()` 和 `class()` 来获取一些类型信息：
- en: '[PRE94]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This time, the type is `S4` instead of `list` or other data types, and the
    class is the name of the S4 class. The S4 object is also a first-class citizen
    in R because it has a checking function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，类型是 `S4` 而不是 `list` 或其他数据类型，类名是 S4 类的名称。S4 对象在 R 中也是一个一等公民，因为它有一个检查函数：
- en: '[PRE95]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Unlike accessing a list or environment with `$`, we need to use `@` to access
    a slot of an S4 object:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `$` 访问列表或环境不同，我们需要使用 `@` 来访问 S4 对象的槽位：
- en: '[PRE96]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Alternatively, we can call `slot()` to access a slot with its name as a string.
    This is equivalent to accessing an element of a list or environment with double
    brackets (`[[]]`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以调用 `slot()` 使用其名称作为字符串来访问槽位。这相当于使用双括号 (`[[]]`) 访问列表或环境中的元素：
- en: '[PRE97]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We can also modify an S4 object in the same way we modify a list:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像修改列表一样修改 S4 对象：
- en: '[PRE98]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'However, we cannot supply to a slot something that is not consistent with the
    class representation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能向槽位提供与类表示不一致的东西：
- en: '[PRE99]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Neither can we create a new slot just like adding a new element to a list because
    the structure of an S4 object is fixed to its class representation:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不能像向列表添加新元素一样创建新的槽位，因为 S4 对象的结构固定为其类表示：
- en: '[PRE100]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we will create another instance with the values of slots partially supplied:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个部分提供槽位值的实例：
- en: '[PRE101]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The preceding code does not specify `inventory`, so the resulting object, `toy`,
    takes an empty integer vector as `inventory`. If you think it is not a good default
    value, we can specify a prototype of the class so that each instance will be created
    from it as a template:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有指定 `inventory`，因此生成的对象 `toy` 将一个空整数向量作为 `inventory`。如果你认为这不是一个好的默认值，我们可以指定类的原型，这样每个实例都将从这个模板创建：
- en: '[PRE102]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In the preceding prototype, we set the default value of `price` to be the numeric
    missing value and inventory to be integer zero. Note that `NA` is logical and
    cannot be used here because it is not consistent with the class representation.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，我们将 `price` 的默认值设置为数值缺失值，将库存设置为整数零。请注意，`NA` 是逻辑值，不能在这里使用，因为它与类表示不一致。
- en: 'Then, we will recreate `toy` with the same code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用相同的代码重新创建 `toy`：
- en: '[PRE103]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This time, `inventory` takes the default value `0L` from the prototype. However,
    what if we need more constraints on the input arguments? Although the classes
    of the arguments are checked, we can still supply values that are not meaningful
    as an instance of `Product`. For example, we can create a `bottle` class with
    negative inventory:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`inventory`从原型中获取默认值`0L`。但是，如果我们需要对输入参数有更多的约束呢？尽管检查了参数的类，我们仍然可以提供对`Product`实例来说没有意义的值。例如，我们可以创建一个具有负库存的`bottle`类：
- en: '[PRE104]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The following code is a validation function that ensures that the slots of a
    `Product` object are meaningful. The validation function is somehow special because
    when there is no error about the input object, it should return `TRUE`. When there
    are errors, it should return a character vector that describe the errors. Therefore,
    it is best not to use `stop()` or `warning()` when a slot is not valid.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个验证函数，它确保`Product`对象的槽位是有意义的。验证函数有些特殊，因为当输入对象没有错误时，它应该返回`TRUE`。当存在错误时，它应该返回一个描述错误的字符向量。因此，当槽位无效时，最好不使用`stop()`或`warning()`。
- en: 'Here, we will validate the object by checking the length of each slot and whether
    they are missing values. Also, the price must be positive, and the inventory must
    be non-negative:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过检查每个槽位的长度以及它们是否为缺失值来验证对象。此外，价格必须是正数，库存必须是非负数：
- en: '[PRE105]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We write a long combination of values to make up the error messages. This works
    because `if (FALSE) expr` returns `NULL` and `c(x, NULL)` returns `x`. At last,
    if no error message is produced, the function returns `TRUE`, otherwise it returns
    the error messages.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写一个长的值组合来构成错误消息。这之所以有效，是因为`if (FALSE) expr`返回`NULL`，而`c(x, NULL)`返回`x`。最后，如果没有产生错误消息，函数返回`TRUE`，否则返回错误消息。
- en: 'With this function defined, we can directly use it to validate `bottle`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个函数后，我们可以直接使用它来验证`bottle`：
- en: '[PRE106]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The validation results in an error message as supposed. Now, we need to make
    the class perform validation each time an instance is being created. We only need
    to specify the `validity` argument when we use `setClass` for `Product` class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 验证结果是一个错误消息，正如预期的那样。现在，我们需要让类在每次创建实例时执行验证。我们只需要在为`Product`类使用`setClass`时指定`validity`参数：
- en: '[PRE107]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then, each time we try to create an instance of the `Product` class, the supplied
    values are automatically checked. Even the prototype is checked. Here are two
    cases that fail the validation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次我们尝试创建`Product`类的实例时，提供的值都会自动进行检查。即使是原型也会进行检查。以下是两个验证失败的例子：
- en: '[PRE108]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The preceding code fails because the default value of `price` is `NA_real_`
    in the prototype. In the validation, however, the price cannot be a missing value:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码失败是因为原型中`price`的默认值是`NA_real_`。然而，在验证过程中，价格不能是缺失值：
- en: '[PRE109]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This fails because `inventory` must be a non-negative integer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这失败了，因为`inventory`必须是非负整数。
- en: Note that the validation only occurs when we create a new instance of an S4
    class. Once the object is created, however, the validation does not happen anymore.
    In other words, we can still set a slot to a bad value unless we explicitly validate
    it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，验证只在创建S4类的新实例时发生。然而，一旦对象被创建，验证就不会再发生。换句话说，除非我们显式验证，否则我们仍然可以将槽位设置为不良值。
- en: Understanding S4 inheritance
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解S4继承
- en: The S3 system is loose and flexible. Each S3 object of the same class may have
    different members. For S4, however, this cannot happen, that is, we cannot arbitrarily
    add a slot that is not in the class definition when we create a new instance of
    the class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: S3系统是宽松和灵活的。同一类的每个S3对象可能有不同的成员。对于S4，这种情况不会发生，也就是说，当我们创建类的新实例时，我们不能随意添加不在类定义中的槽位。
- en: 'For example, we cannot put a `volume` slot when we create a new instance of `Product`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们创建`Product`的新实例时，我们不能放置`volume`槽位：
- en: '[PRE110]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Instead, we can only do this through proper inheritance. We need to create
    a new class that contains (or inherits from) the original class. In this case,
    we can define a `Container` class that inherits from `Product` and has a new numeric
    slot named `volume`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只能通过适当的继承来完成这个操作。我们需要创建一个新的类，该类包含（或继承自）原始类。在这种情况下，我们可以定义一个继承自`Product`并具有名为`volume`的新数值槽的`Container`类：
- en: '[PRE111]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Since `Container` inherits from `Product`, any instance of `Container` has
    all the slots of `Product`. We can use `getSlots()` to view them:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Container`继承自`Product`，任何`Container`的实例都具有`Product`的所有槽位。我们可以使用`getSlots()`来查看它们：
- en: '[PRE112]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, we can create an instance of `Container` that has a `volume` slot:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个具有 `volume` 插槽的 `Container` 实例：
- en: '[PRE113]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Note that the validation of `Product` still functions when we create an instance
    of `Container`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们创建 `Container` 实例时，`Product` 的验证仍然有效：
- en: '[PRE114]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Therefore, the checking ensures it is a valid `Product` class, but it still
    does not check anything about `Container`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查确保它是一个有效的 `Product` 类，但它仍然不检查 `Container` 的任何内容：
- en: '[PRE115]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Just like we defined a validation function for `Product`, we can define another
    for `Container`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为 `Product` 定义了一个验证函数一样，我们也可以为 `Container` 定义另一个：
- en: '[PRE116]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Then, we will redefine `Container` with this validation function:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用此验证函数重新定义 `Container`：
- en: '[PRE117]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Note that we don''t need to call `validate_product` in `validate_container`
    because both validation functions will be called in turn to make sure all classes
    in the inheritance chain are properly checked with their validation functions.
    You may add some text-printing code to the validating functions to confirm that `validate_product`
    is always called before `validate_container` when we create an instance of `Container`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在 `validate_container` 中调用 `validate_product`，因为两个验证函数将依次被调用，以确保继承链中的所有类都通过它们的验证函数得到适当的检查。你可以在验证函数中添加一些文本打印代码，以确认当我们创建
    `Container` 实例时，`validate_product` 总是在 `validate_container` 之前被调用：
- en: '[PRE118]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Defining S4 generic functions
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 S4 泛型函数
- en: In the previous examples, we saw that S4 is much more formal than S3 because
    the S4 class requires a class definition. Likewise, S4 generic functions are more
    formal too.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了 S4 比S3 更正式，因为 S4 类需要类定义。同样，S4 泛型函数也更正式。
- en: 'Here is an example where we define a series of S4 classes with a simple hierarchy
    of inheritance relationships. The example is about shapes. First, `Shape` is a
    root class. Both `Polygon` and `Circle` inherit from `Shape`, while `Triangle`
    and `Rectangle` inherit from `Polygon`. The inheritance structure of these shapes
    is illustrated here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，我们定义了一系列具有简单继承关系的 S4 类。这个例子是关于形状的。首先，`Shape` 是一个根类。`Polygon` 和 `Circle`
    都继承自 `Shape`，而 `Triangle` 和 `Rectangle` 继承自 `Polygon`。这些形状的继承结构在此处展示：
- en: '![Defining S4 generic functions](img/image_10_005.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![定义 S4 泛型函数](img/image_10_005.jpg)'
- en: 'Each class except `Shape` has some necessary slots to describe itself:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Shape` 之外，每个类都有一些必要的插槽来描述自己：
- en: '[PRE119]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'With these classes defined, we can set up a generic function to calculate the
    area of a `Shape` object. To do this, we need to call `setGeneric()` upon `area`
    and supply a function that calls `standardGeneric("area")` to make `area` a generic
    function and ready for S4 method dispatch. The `valueClass` is used to ensure
    that the return value of each method must be of class `numeric`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些类之后，我们可以设置一个泛型函数来计算 `Shape` 对象的面积。为此，我们需要在 `area` 上调用 `setGeneric()` 并提供一个函数，该函数调用
    `standardGeneric("area")` 使 `area` 成为泛型函数，并准备好进行 S4 方法调度。`valueClass` 用于确保每个方法的返回值必须是
    `numeric` 类：
- en: '[PRE120]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Once the generic function is set up, we go on to implement different methods
    for different kinds of shapes. For `Triangle`, we use Heron''s formula ([https://en.wikipedia.org/wiki/Heron''s_formula](https://en.wikipedia.org/wiki/Heron''s_formula))
    to calculate its area, given the lengths of the three sides:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了泛型函数，我们就继续实现不同形状的不同方法。对于 `Triangle`，我们使用海伦公式 ([https://en.wikipedia.org/wiki/Heron's_formula](https://en.wikipedia.org/wiki/Heron's_formula))
    来计算其面积，给定三边的长度：
- en: '[PRE121]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'For `Rectangle` and `Circle`, it is easy to write out the area formula for
    each of them:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Rectangle` 和 `Circle`，很容易写出它们各自的面积公式：
- en: '[PRE122]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, we can create an instance of `Triangle` and see whether `area()` dispatches
    to the correct method and returns the correct answer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 `Triangle` 实例，并查看 `area()` 是否调度到正确的方法并返回正确的结果：
- en: '[PRE123]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We also create an instance of `Circle` and see whether method dispatch works:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个 `Circle` 实例，并查看方法调度是否工作：
- en: '[PRE124]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Both answers are correct. The `area()` function just works like an S3 generic
    function that performs method dispatch according to the class of the input object.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 两个答案都是正确的。`area()` 函数就像一个执行根据输入对象类进行方法调度的 S3 泛型函数一样工作。
- en: Understanding multiple dispatch
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多态调度
- en: An S4 generic function is more flexible because it also supports multiple dispatch,
    that is, it can perform method dispatch according to the classes of multiple arguments.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: S4 泛型函数更灵活，因为它还支持多态调度，即它可以根据多个参数的类执行方法调度。
- en: 'Here, we will define another family of S4 classes: `Object` with a numeric `height`.
    Both `Cylinder` and `Cone` inherit from `Object`. Later, we will use multiple
    dispatch to calculate the volume of a certain type of geometric object with a
    certain shape of the bottom surface:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义另一组S4类：具有数值`height`的`Object`。`Cylinder`和`Cone`都继承自`Object`。稍后，我们将使用多分派来计算具有特定底部形状的几何对象的体积：
- en: '[PRE125]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, we will define a new generic function named `volume`. As its name suggests,
    this function is used to calculate the volume of an object that is described by
    the shape of the bottom surface and the form of the object:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个新的泛型函数，名为`volume`。正如其名所示，此函数用于计算由底部形状和对象形式描述的物体的体积：
- en: '[PRE126]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the following code, we will implement two cases: one is for a rectangle-shaped
    cylinder and the other is for a rectangle-shaped cone:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将实现两种情况：一种是矩形形状的圆柱体，另一种是矩形形状的圆锥体：
- en: '[PRE127]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Note that all existing methods for `volume` require two arguments. Therefore,
    the method dispatch happens with both arguments, that is, it requires the classes
    of both input objects to match to choose the correct method. Now, we will test `volume`
    with an instance of `Rectagle` and an instance of `Cylinder`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有现有的`volume`方法都需要两个参数。因此，方法分派发生在两个参数上，即它需要两个输入对象的类匹配以选择正确的方法。现在，我们将使用`Rectagle`的一个实例和`Cylinder`的一个实例来测试`volume`：
- en: '[PRE128]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Since a relationship holds for a cylinder and a cone with the same height and
    the shape of bottom surface, the volume of the cylinder is three times that of
    the cone. To simplify the implementation of `volume` methods, we can directly
    put `Shape` in the method signature and call `area()` of the shape and directly
    use its area in the calculation:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有相同高度和底部形状的圆柱体和圆锥体之间存在关系，圆柱体的体积是圆锥体的三倍。为了简化`volume`方法的实现，我们可以在方法签名中直接放置`Shape`，并调用形状的`area()`，然后直接使用其面积进行计算：
- en: '[PRE129]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, `volume` is automatically applicable to `Circle`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`volume`可以自动应用于`Circle`：
- en: '[PRE130]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To make `volume` easier to use, we can also define a method that takes an instance
    of `Shape` and a numeric value as the height of the cylinder:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`volume`更容易使用，我们还可以定义一个方法，该方法接受一个`Shape`的实例和一个表示圆柱体高度的数值：
- en: '[PRE131]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Then, we can directly use numeric values in calculating the volume of the cylinder
    given its shape and height:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以直接使用数值来计算给定形状和高度的圆柱体的体积：
- en: '[PRE132]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Furthermore, we can simplify the notation by implementing a method of `*`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过实现一个`*`方法来简化表示法：
- en: '[PRE133]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, we can calculate the volume by simply multiplying the shape and the object
    form:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地乘以形状和对象形式来计算体积：
- en: '[PRE134]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note that an S4 object is not a list or environment, but it has copy-on-modify
    semantics. In this sense, when the value of a slot of an S4 object is modified
    by `<-` in a function, it behaves more like a list, that is, the S4 object is
    copied in the function and the original object is not modified.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，S4对象不是一个列表或环境，但它具有修改时复制的语义。从这个意义上讲，当函数中使用`<-`修改S4对象的槽值时，它表现得更像一个列表，即S4对象在函数中被复制，而原始对象没有被修改。
- en: 'For example, in the following code, we will define a function that tries to
    lengthen `Object` by multiplying its height with a numeric factor:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码中，我们将定义一个函数，该函数尝试通过将`Object`的高度与一个数值因子相乘来延长`Object`：
- en: '[PRE135]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'When we apply this function on `cylinder`, which we previously created, its
    height is not changed at all. Instead, it is copied inside the function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此函数应用于我们之前创建的`cylinder`时，其高度完全没有改变。相反，它在函数内部被复制：
- en: '[PRE136]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Working with the reference class
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与引用类一起工作
- en: There is also a class system that has reference semantics. It is more like the
    class system in other object-oriented programming languages.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个具有引用语义的类系统。它更类似于其他面向对象编程语言中的类系统。
- en: 'First, to define a reference class (**RC**), we supply a class definition to `setRefClass()`.
    Unlike the S4 class system where we use `new()` to create an instance, `setRefClass()`
    returns an instance generator. For example, we define a class named `Vehicle`,
    which has two fields: a numeric position and a numeric distance. We store the
    instance generator to a variable named `Vehicle`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了定义一个引用类（**RC**），我们向`setRefClass()`提供一个类定义。与使用`new()`创建实例的S4类系统不同，`setRefClass()`返回一个实例生成器。例如，我们定义一个名为`Vehicle`的类，它有两个字段：一个数值位置和一个数值距离。我们将实例生成器存储在一个名为`Vehicle`的变量中：
- en: '[PRE137]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'To create an instance, we use `Vehicle$new` to create new instances of the `Vehicle`
    class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建实例，我们使用`Vehicle$new`创建`Vehicle`类的新实例：
- en: '[PRE138]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Unlike S4, the fields of RC are not slots, so we can use `$` to access them:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与S4不同，RC的字段不是槽，因此我们可以使用`$`来访问它们：
- en: '[PRE139]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Each instance we create with `Vehicle$new` is an object of reference semantics.
    It behaves like a combination of S4 object and environment.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Vehicle$new`创建的每个实例都是引用语义的对象。它类似于S4对象和环境的组合。
- en: 'In the following code, we will create a function that modifies the fields in
    a `Vehicle` object. More specifically, we define `move` that modifies `position`
    in relative terms, and all movements are accumulated to `distance`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将创建一个函数来修改`Vehicle`对象中的字段。更具体地说，我们定义了`move`来修改相对术语中的`position`，并且所有移动都累积到`distance`：
- en: '[PRE140]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, we will call `move` with `car`, and the instance we created is modified
    rather than copied:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`car`调用`move`，我们创建的实例被修改而不是复制：
- en: '[PRE141]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Since RC itself is a class system more like ordinary object-oriented system,
    a better way to do this is to define its own methods of the class:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RC本身更像是一个普通面向对象系统中的类系统，更好的做法是定义它自己的类方法：
- en: '[PRE142]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Unlike S3 and S4 systems where methods are stored in the environment, RC directly
    include its methods. Therefore, we can directly call the method inside an instance.
    Note that to modify the value of a field in a method, we need to use `<<-` instead
    of `<-`. The following code is a simple test to check whether the method works
    and whether the reference object is modified:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 与S3和S4系统不同，其中方法存储在环境中，RC直接包含其方法。因此，我们可以直接在实例内部调用方法。请注意，要修改方法中字段的值，我们需要使用`<<-`而不是`<-`。以下代码是一个简单的测试，用于检查方法是否工作以及引用对象是否被修改：
- en: '[PRE143]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: From the preceding examples, we can see that RC looks more like the objects
    in C++ and Java. For more detailed introduction, read `?ReferenceClasses`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们可以看到RC看起来更像C++和Java中的对象。对于更详细的介绍，请阅读`?ReferenceClasses`。
- en: Working with R6
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与R6一起工作
- en: An enhanced version of RC is R6, a package that implements a more efficient
    reference class that supports public and private fields and methods, and some
    other powerful features.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: RC的增强版本是R6，这是一个实现更高效参考类的包，支持公共和私有字段和方法，以及一些其他强大功能。
- en: 'Run the following code to install the package:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码来安装包：
- en: '[PRE144]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The R6 class allows us to define classes that are even more like popular object-oriented
    programming languages. The following code is an example where we define the `Vehicle`
    class. It has some public fields and methods for users and some private fields
    and methods for internal use:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: R6类允许我们定义更类似于流行面向对象编程语言的类。以下代码是一个示例，其中我们定义了`Vehicle`类。它为用户提供了一些公共字段和方法，并为内部使用定义了一些私有字段和方法：
- en: '[PRE145]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'From the user side, we can only access the public fields and methods. Only
    the class methods have access to the private fields and methods. Although the
    vehicle has a position, we don''t want the user to modify its value. Therefore,
    we put it in the private part and expose its value through `get_position()` so
    that it is hard for users to modify the position from outside:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，我们只能访问公共字段和方法。只有类方法可以访问私有字段和方法。尽管车辆有一个位置，但我们不希望用户修改其值。因此，我们将其放在私有部分，并通过`get_position()`公开其值，这样用户就很难从外部修改位置：
- en: '[PRE146]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'When `car` is printed, all public and private fields and methods are displayed.
    Then, we will call the `move()` method, and we can find the position is changed
    with `get_position()`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印`car`时，所有公共和私有字段和方法都会显示出来。然后，我们将调用`move()`方法，我们可以通过`get_position()`找到位置已改变：
- en: '[PRE147]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'To demonstrate the inheritance of R6 class, we define a new class named `MeteredVehicle`
    that records the sum of distance it moves in history. To define the class, we
    need to add a private field `distance`, a public override of `move` that first
    calls `super$move()` to move the vehicle to get the right position and then accumulates
    the distance resulted from the movement in absolute terms:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示R6类的继承，我们定义一个新的类名为`MeteredVehicle`，该类记录其在历史中移动的总距离。为了定义该类，我们需要添加一个私有字段`distance`，一个公共重写的`move`方法，该方法首先调用`super$move()`将车辆移动到正确位置，然后累积由此产生的绝对距离：
- en: '[PRE148]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now, we can do some experiments with `MeteredVehicle`. In the following code,
    we will create a `bus`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对`MeteredVehicle`进行一些实验。在以下代码中，我们将创建一个`bus`：
- en: '[PRE149]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'First, let `bus` move `10` units forward, and then, the position is changed
    and the distance is accumulated:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让`bus`向前移动`10`个单位，然后，位置改变，距离累积：
- en: '[PRE150]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, let `bus` move `5` units backward. The position is closer to the origin,
    while the distance that sums up all movements becomes greater:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让`bus`向后移动`5`个单位。位置更接近原点，而所有移动的总距离变得更大：
- en: '[PRE151]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Note
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: R6 also supports some other powerful features. For more details, read its vignettes
    at [https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html](https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: R6还支持一些其他强大的功能。更多详情，请阅读其vignettes在[https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html](https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html)。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned the basic concepts of object-oriented programming:
    class and methods and how they are connected by generic functions in R through
    method dispatch. You learned how to create S3, S4, RC, and R6 classes and methods.
    These systems share similar ideas but are distinct in implementation and usage.
    Hadley Wickham gives some nice suggestions in picking a system ([http://adv-r.had.co.nz/OO-essentials.html#picking-a-system](http://adv-r.had.co.nz/OO-essentials.html#picking-a-system)).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了面向对象编程的基本概念：类和方法以及它们如何通过R中的泛型函数通过方法调度相互连接。你学习了如何创建S3、S4、RC和R6类和方法。这些系统在理念上相似，但在实现和使用上有所不同。Hadley
    Wickham在挑选系统方面提供了一些不错的建议（[http://adv-r.had.co.nz/OO-essentials.html#picking-a-system](http://adv-r.had.co.nz/OO-essentials.html#picking-a-system)）。
- en: After getting familiar with R's most important features, we will discuss more
    practical topics in the subsequent chapters. In the next chapter, you will learn
    about the packages and techniques used to access popular databases. You will gain
    necessary knowledge and techniques to connect R to relational databases such as
    SQLite and MySQL as well as the upcoming non-relational databases such as MongoDB
    and Redis.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉R最重要的特性之后，我们将在后续章节中讨论更多实际话题。在下一章中，你将学习用于访问流行数据库的包和技术。你将获得连接R到关系数据库（如SQLite和MySQL）以及即将到来的非关系数据库（如MongoDB和Redis）所必需的知识和技术。
