- en: Chapter 9.  Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。元编程
- en: In the previous chapter, you learned about the structure and features of an
    environment and also learned how to create and access an environment. Environment
    plays an important role in lazy evaluation, copy-on-modify, and lexical scoping,
    which are enabled by the environments associated with a function when it is created
    and called.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了环境和其特性的结构，也学习了如何创建和访问一个环境。环境在懒加载、修改时复制和词法作用域中扮演着重要角色，这些都是在函数创建和调用时通过环境实现的。
- en: 'Now that we have a solid understanding of how functions work, we will go further
    in this chapter by learning to work with functions in more advanced forms. You
    will learn the metaprogramming facilities that make R flexible in interactive
    analysis. More specifically, we will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对函数的工作原理有了坚实的理解，我们将在本章中进一步学习如何以更高级的形式与函数一起工作。你将学习使R在交互式分析中灵活的元编程功能。更具体地说，本章将涵盖以下主题：
- en: 'Functional programming: closures and higher-order functions'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程：闭包和高阶函数
- en: Computing on language with language objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语言对象进行语言计算
- en: Understanding non-standard evaluation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解非标准评估
- en: Understanding functional programming
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: 'In the previous chapter, you learned the behavior of a function in detail,
    including when an argument is evaluated (lazy evaluation), what happens when we
    try to modify an argument (copy-on-modify), and where to look for variables not
    defined within the function (lexical scoping). These technical terms that describe
    the behaviors may look more difficult than they actually are. In the following
    sections, you will learn about two types of functions: functions that are defined
    in functions and functions that work with other functions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你详细学习了函数的行为，包括当参数被评估时（懒加载）、尝试修改参数时会发生什么（修改时复制），以及在哪里查找函数内部未定义的变量（词法作用域）。描述这些行为的术语可能看起来比实际要难。在接下来的章节中，你将了解两种类型的函数：在函数中定义的函数和与函数一起工作的函数。
- en: Creating and using closures
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用闭包
- en: A function defined in a function is called a **closure_**. It is special because
    in the function body of the closure, not only the local arguments but also the
    variables created in the parent function are also available.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中定义的函数称为**闭包**。它很特别，因为在闭包的函数体中，不仅可以使用局部参数，还可以使用父函数中创建的变量。
- en: 'For example, suppose we have the following function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function has two arguments. Each time we call `add()`, we should supply
    two arguments. If we use closure, we can generate special versions of this function
    with a pre-specified argument. In the following section, we will create a simple
    closure to accomplish this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数。每次我们调用`add()`时，我们都应该提供两个参数。如果我们使用闭包，我们可以生成具有预指定参数的特殊版本的这个函数。在下一节中，我们将创建一个简单的闭包来完成这个任务。
- en: Creating a simple closure
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建简单的闭包
- en: 'Here, we will create a function called `addn`, which has one argument `y`.
    This function does not do the actual plus calculation but creates a child function
    that adds `y` to whatever number `x` supplied:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个名为`addn`的函数，它有一个参数`y`。这个函数并不执行实际的加法计算，而是创建一个子函数，该子函数将`y`加到提供的任何数字`x`上：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It may take extra efforts to realize that `addn` does not return a number like
    a typical function, but returns a closure: that is, a function defined in a function.
    The closure calculates `x + y`, where `x` refers to a local argument and `y` refers
    to an argument in its enclosing environment. In other words, `addn()` is no longer
    a calculator, but a calculator factory that manufactures calculators.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要额外的努力才能意识到`addn`并不像典型函数那样返回一个数字，而是返回一个闭包：即在函数中定义的函数。闭包计算`x + y`，其中`x`指的是局部参数，而`y`指的是其封装环境中的参数。换句话说，`addn()`不再是一个计算器，而是一个制造计算器的计算器工厂。
- en: 'The factory function enables us to create specialized versions of calculators.
    For example, we can create two functions that add `1` and `2` to a numeric vector,
    respectively:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数使我们能够创建计算器的专用版本。例如，我们可以创建两个函数，分别将`1`和`2`加到数值向量上：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The two functions work as if the second argument of `add(x, y)` was fixed.
    The following code validates the calculators made by `addn()`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数表现得好像`add(x, y)`的第二个参数是固定的。以下代码验证了`addn()`制作的计算器：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Take `add1` as an example. The `add1 <- addn(1)` code evaluates `addn(1)`,
    which results in a function assigned to `add1`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以`add1`为例。`add1 <- addn(1)`代码评估`addn(1)`，结果将一个函数分配给`add1`：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we print `add1`, it is a bit different because the environment of `add1`
    is also attached. The environment of a function will be printed if it is not the
    current environment-in this case, the global environment. In the environment of
    `add1`, `y` is specified in `addn(1)`, which can be verified by running the following
    code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印`add1`时，它略有不同，因为`add1`的环境也被附加了。如果函数的环境不是当前环境，则函数的环境将被打印出来——在这种情况下，是全局环境。在`add1`的环境中，`y`是在`addn(1)`中指定的，可以通过运行以下代码来验证：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can call `environment()` with `add1` to access its enclosing environment,
    which captures `y`. That''s exactly how closure works. We can do the same thing
    to `add2` and see the value of `y` we specified with `addn(2)`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`add1`调用`environment()`来访问其封闭环境，该环境捕获`y`。这正是闭包的工作方式。我们可以对`add2`做同样的事情，看看我们用`addn(2)`指定的`y`的值：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Making specialized functions
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作专用函数
- en: Closures are useful to make specialized functions. For example, due to the flexibility
    of the production of graphics, plot functions often provide a large number of
    arguments. If we frequently use only a particular subset of all arguments, we
    can make specialized versions that make the code easier to write and read.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包对于制作专用函数很有用。例如，由于图形生产的灵活性，绘图函数通常提供大量的参数。如果我们经常只使用所有参数的一个特定子集，我们可以制作专门的版本，使代码更容易编写和阅读。
- en: 'The following `color_line` function is a version of `plot` specialized in color
    picking, but with plot type and line type being fixed. It is comparable to a factory
    that makes pens of all colors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`color_line`函数是`plot`的一个版本，专门用于颜色选择，但固定了绘图类型和线条类型。它相当于一个制造所有颜色笔的工厂：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we want a red pen, we call `color_line` and get a specialized function that
    draws red lines. The resulted function is also open to other arguments such as
    title and font:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一支红笔，我们调用`color_line`并得到一个专门绘制红色线条的函数。生成的函数也接受其他参数，例如标题和字体：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function produces the following line plot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数生成以下线图：
- en: '![Making specialized functions](img/image_09_001.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![制作专用函数](img/image_09_001.jpg)'
- en: 'The preceding code looks more readable than the original version that does
    not employ such a specialized function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码比没有使用此类专用函数的原始版本更易于阅读：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fitting normal distribution with maximal likelihood estimation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最大似然估计（MLE）拟合正态分布
- en: 'Closures are useful when we work with an algorithm with some given data. Optimization,
    for example, is a problem to find a set of parameters that maximizes or minimizes
    a pre-defined objective function subject to certain constraints and data. In statistics,
    many parameter estimation problems are, in essence, optimization problems. One
    good example that demonstrates the use of closures is **MLE** (**maximum likelihood
    estimation**). When we estimate the parameters of a statistical model with data,
    we often use the method of maximal likelihood estimation (MLE, see [https://en.wikipedia.org/wiki/Maximum_likelihood](https://en.wikipedia.org/wiki/Maximum_likelihood)).
    The idea behind MLE is simple: the estimated values of parameters should make
    the observed data the most probable, given the model.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与某些给定数据一起工作算法时，闭包很有用。例如，优化是一个寻找一组参数的问题，这些参数在满足某些约束和数据的情况下最大化或最小化预定义的目标函数。在统计学中，许多参数估计问题本质上都是优化问题。一个很好的例子是**最大似然估计（MLE）**，它展示了闭包的使用。当我们用数据估计统计模型的参数时，我们通常使用最大似然估计法（MLE，见[https://en.wikipedia.org/wiki/Maximum_likelihood](https://en.wikipedia.org/wiki/Maximum_likelihood)）。MLE背后的思想很简单：参数的估计值应该使观察到的数据在给定模型下最有可能。
- en: To perform MLE, we need a function that measures how probable it is to observe
    a given set of data under a specific model. Then, we apply optimization techniques
    to find out the values of parameters that maximizes the probability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行最大似然估计（MLE），我们需要一个函数来衡量在特定模型下观察给定数据集的可能性。然后，我们应用优化技术来找出最大化概率的参数值。
- en: 'For example, we know that a set of observed data is generated by normal distribution,
    but the problem is, we don''t know the parameters: mean and standard deviation.
    Then, we can use MLE to estimate them, given the observed data.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道一组观测数据是由正态分布生成的，但问题在于，我们不知道参数：均值和标准差。然后，我们可以使用最大似然估计（MLE）来估计它们，给定观测数据。
- en: "First, we know that the probability density function of a normal distribution\
    \ with mean *Âµ[0]* and standard deviation *Ï\x83[0]* is:"
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们知道均值为*μ[0]*和标准差*σ[0]*的正态分布的概率密度函数是：
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_002.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用最大似然估计拟合正态分布](img/image_09_002.jpg)'
- en: 'Therefore, the likelihood function given the observed data *x* is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定观测数据*x*的似然函数是：
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_003.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![使用最大似然估计拟合正态分布](img/image_09_003.jpg)'
- en: 'To make the optimization easier, we will take a natural log and negate on both
    sides and get the negative log-likelihood function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使优化更容易，我们将取自然对数并在两边取负，得到负对数似然函数：
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用最大似然估计拟合正态分布](img/image_09_004.jpg)'
- en: The negative log-likelihood function has the same monotonicity as the original
    function. The optimization solution of this function is the same as the original
    function but can be much easier to solve. That's why we use this function in the
    estimation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 负对数似然函数与原始函数具有相同的单调性。此函数的优化解与原始函数相同，但可能更容易解决。这就是为什么我们在估计中使用此函数的原因。
- en: 'The following `nloglik` R function returns a closure of the two parameters
    of normal distribution given the observed data `x`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`nloglik` R函数根据观测数据`x`返回正态分布的两个参数的闭包：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this way, for any given set of observations, we call `nloglike` to get a
    negative log-likelihood function with respect to mean and standard deviation.
    It tells us how unlikely it is for us to observe the given data `x` assuming that
    the true model takes the values of `mean` and `sd` we specify.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，对于任何给定的观测数据集，我们调用`nloglike`来获取关于均值和标准差的负对数似然函数。它告诉我们，在假设真实模型取我们指定的`mean`和`sd`值的情况下，观察到给定数据`x`有多不可能。
- en: 'For example, we use `rnorm()` to generate 10,000 random numbers that are normally
    distributed with mean `1` and standard deviation `2`. Therefore, `mean = 1` and
    `sd = 2` are the true values of the distribution parameters:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用`rnorm()`生成10,000个服从均值为`1`和标准差为`2`的正态分布的随机数。因此，`mean = 1`和`sd = 2`是分布参数的真实值：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we turn to the `mle()` function in the `stats4` package. This function
    implements a number of numeric methods to find the minimum value of a given negative
    log-likelihood function with certain parameters. It takes a starting point of
    the numeric search, and a lower bound and a upper bound of the solution:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向`stats4`包中的`mle()`函数。此函数实现了一系列数值方法来找到给定负对数似然函数的极小值，并带有某些参数。它接受数值搜索的起点，以及解的下界和上界：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After some iterations, it finds an MLE solution and returns an S4 object, which
    includes the related data of the solution. To see how close the estimates are
    to the true value, we will extract the `coef` slot from the object:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次迭代后，它找到了最大似然估计解并返回一个S4对象，其中包含与解相关的数据。为了查看估计值与真实值有多接近，我们将从对象中提取`coef`槽：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is obvious that the estimates are very close to the true values. Relatively
    speaking, both estimates have an error lower than 1 percent, as can be verified
    here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，估计值非常接近真实值。相对而言，两个估计值都有低于1%的误差，这可以在下面验证：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following function is a composition of the histogram of `data` and the
    density functions of the normal distribution with both true parameters (red curve)
    and estimated parameters (blue curve):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是`data`的直方图和具有真实参数（红色曲线）和估计参数（蓝色曲线）的正态分布密度函数的组合：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This produces the following histogram, plus a fitted normal density curve:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下直方图，以及一个拟合的正态密度曲线：
- en: '![Fitting normal distribution with maximal likelihood estimation](img/image_09_005.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用最大似然估计拟合正态分布](img/image_09_005.jpg)'
- en: We can see that the density function produced by the estimated parameters is
    very close to the true model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由估计参数产生的密度函数非常接近真实模型。
- en: Using higher-order functions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: In the previous section, we discussed closures, functions defined in parent
    functions. In this section, we will discuss higher-order functions, that is, functions
    that accept another function as an argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了闭包，即在父函数中定义的函数。在本节中，我们将讨论高阶函数，即接受另一个函数作为参数的函数。
- en: Before walking into this topic, we need more knowledge of how functions behave
    when they are passed around either as variables or as function arguments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入这个主题之前，我们需要更多关于函数在作为变量或函数参数传递时的行为的知识。
- en: Creating aliases for functions
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为函数创建别名
- en: 'The first question is: if we assign an existing function to another variable,
    will it affect the enclosing environment of the function? If this is so, then
    the search paths of symbols that are not locally defined will be different.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题：如果我们将现有函数赋值给另一个变量，它会影响函数的封装环境吗？如果是这样，那么未在局部定义的符号的搜索路径将不同。
- en: The following code demonstrates why the enclosing environment of a function
    is not changed when it is assigned to another symbol. We define a simple function
    `f1` that prints the executing environment, the enclosing environment, and the
    calling environment when it is called. Then, we define `f2` that also prints the
    three environments, but in addition, it assigns the function of `f1` to a local
    variable `p` and call `p` inside `f2`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了为什么将函数赋值给另一个符号时，封装环境不会改变。我们定义了一个简单的函数`f1`，它在被调用时打印执行环境、封装环境和调用环境。然后，我们定义了`f2`，它也打印了这三个环境，但除此之外，它还将`f1`的函数赋值给局部变量`p`，并在`f2`内部调用`p`。
- en: 'If `p <- f1` defines the function locally, the enclosing environment of `p`
    will be the executing environment of `f2`. Otherwise, the enclosing environment
    will remain the global environment in which `f1` is defined:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`p <- f1`在局部定义了函数，则`p`的封装环境将是`f2`的执行环境。否则，封装环境将保持为定义`f1`的全局环境：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We called the two functions in turn and found that `p` is called from the executing
    environment of `f2`, but the enclosing environment is unchanged. In other words,
    the search path of `p` and `f1` are exactly the same. In fact, `p <- f1` assigns
    exactly the same function `f1` represents to `p`, and then, they both point to
    the same function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依次调用了这两个函数，发现`p`是在`f2`的执行环境中被调用的，但封装的环境没有改变。换句话说，`p`和`f1`的搜索路径完全相同。实际上，`p
    <- f1`将`f1`表示的相同函数赋值给`p`，然后它们都指向同一个函数。
- en: Using functions as variables
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数用作变量
- en: Functions in R are not as special as they are in other programming languages.
    Everything is an object. Functions are objects too and can be referred to by variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: R中的函数并不像在其他编程语言中那样特殊。一切都是对象。函数也是对象，并且可以通过变量引用。
- en: 'Suppose we have a function like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个这样的函数：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding function, two conditional branches lead to different expressions
    that may result in different values. To achieve the same goal, we can also let
    the conditional branches result in different functions, store the result in a
    variable, and, finally, call the function the variable represents to get the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，两个条件分支导致不同的表达式，可能产生不同的值。为了达到相同的目的，我们也可以让条件分支产生不同的函数，将结果存储在变量中，最后调用变量表示的函数以获取结果：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that in R, everything we do is done by a function. The most basic operators
    `+` and `-` are functions too. They can be assigned to the variable `op`, and
    we can call `op` if it is indeed a function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在R中，我们做的所有事情都是通过函数完成的。最基本的运算符`+`和`-`也是函数。它们可以被赋值给变量`op`，如果`op`确实是一个函数，我们就可以调用它。
- en: Passing functions as arguments
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: The previous examples demonstrate that we can easily pass functions around just
    like everything else, including passing functions in arguments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子表明，我们可以像传递其他任何东西一样轻松地传递函数，包括在参数中传递函数。
- en: 'In the following example, we will define two functions called `add` and `product`,
    respectively:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将定义两个函数，分别称为`add`和`product`：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we will define another function, `combine`, that tries to combine `x`,
    `y`, and `z` in some way specified by the argument `f`. Here,`f` is assumed to
    be a function that takes three arguments as we call it. In this way, `combine`
    is more flexible. It is not limited to a particular way of combining the inputs,
    but allows the user to specify:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义另一个名为`combine`的函数，它试图以参数`f`指定的某种方式组合`x`、`y`和`z`。在这里，`f`被假设为一个接受三个参数的函数，正如我们调用它时那样。这样，`combine`就更加灵活。它不仅限于特定的组合输入方式，还允许用户指定：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can pass `add` and `product`, we just defined in turn, to see if it works:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们刚刚定义的`add`和`product`传递过去，看看它是否工作：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is natural that when we call `combine(add, 3, 4, 5)`, the function body has
    `f = add` and `f(x, y, z)`, which result in `add(x, y, z)`. The same logic also
    applies to calling `combine` with `product`. Since `combine` accepts a function
    in its first argument, it is indeed a higher-order function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`combine(add, 3, 4, 5)`时，函数体有`f = add`和`f(x, y, z)`，这导致`add(x, y, z)`。同样的逻辑也适用于使用`product`调用`combine`。由于`combine`接受一个函数作为其第一个参数，它确实是一个高阶函数。
- en: Another reason we need higher-order functions is that the code is easier to
    read and write at a higher level of abstraction. In many cases, using higher-order
    functions make the code shorter yet more expressive. For example, for-loop is
    an ordinary flow-control device that iterates along a vector or list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们需要高阶函数的原因是，在更高层次的抽象级别上，代码更容易阅读和编写。在许多情况下，使用高阶函数可以使代码更短，但表达更丰富。例如，for循环是一个普通的流程控制设备，它沿着向量或列表进行迭代。
- en: 'Suppose we need to apply a function named `f` to each element of vector `x`.
    If the function itself is vectorized, it is better to call `f(x)` directly. However,
    not every function supports vectorized operations, nor does every function need
    to be vectorized. If we want to do so, a for-loop,like the following one, solves
    the problem:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将一个名为`f`的函数应用到向量`x`的每个元素上。如果函数本身是向量化的，最好直接调用`f(x)`。然而，并不是每个函数都支持向量化操作，也不是每个函数都需要向量化。如果我们想这样做，像以下这样的for循环可以解决问题：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous loop, `seq_along(x)` produces a sequence from `1` to the length
    of `x`, which is equivalent to `1:length(x)`. The code looks simple and easy to
    implement, but if we use it all the time, the drawback becomes significant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的循环中，`seq_along(x)`生成从`1`到`x`长度的序列，这相当于`1:length(x)`。代码看起来简单且易于实现，但如果我们总是使用它，缺点就会变得明显。
- en: 'Suppose the operation in each iteration gets more complicated: it would be
    hard to read. If you think about it, you will find that the code tells R *how*
    to finish the task instead of *what* the task is about. When you take a look at
    very long, sometimes nested loops, you would have a hard time to figure out what
    it is actually doing.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每次迭代的操作变得更加复杂：这将很难阅读。如果你仔细想想，你会发现代码告诉R如何完成任务，而不是任务本身是什么。当你查看非常长，有时嵌套的循环时，你可能会很难弄清楚它实际上在做什么。
- en: 'Instead, we can apply a function (`f`) to each element of a vector or list
    (`x`) by calling `lapply`, which we introduced in the previous chapters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以通过调用我们在前面的章节中介绍的`lapply`，将函数（`f`）应用到向量或列表（`x`）的每个元素上：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In fact, `lapply` is essentially the same as the following code, although it
    is implemented in C:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`lapply`本质上与以下代码相同，尽管它是用C实现的：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function is a higher-order function, because it works at a higher level
    of abstraction. Although it still uses a for-loop inside, it separates the work
    into two levels of abstraction so that each level looks simple.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个高阶函数，因为它在更高层次的抽象级别上工作。尽管它仍然在内部使用for循环，但它将工作分为两个抽象级别，使得每个级别看起来都很简单。
- en: 'In fact, `lapply` also supports extending `f` with additional arguments. For
    example, `+` has two arguments, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`lapply`也支持通过额外的参数扩展`f`。例如，`+`有两个参数，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding lines of code are equivalent to:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码等同于：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding line of code is also equivalent to the case where we use a closure
    to produce the `x+3` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码也等同于我们使用闭包来生成`x+3`函数的情况：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we mentioned in the previous chapters, `lapply` only returns a list. If
    we want a vector instead, we should use `sapply` in the interactive mode:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，`lapply`只返回一个列表。如果我们想得到一个向量，我们应该在交互模式下使用`sapply`：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, we should use `vapply` in the programming code with type checking:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们应该在编程代码中使用类型检查的`vapply`：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In addition to these functions, R also offers several other apply-family functions,
    as we mentioned in the previous chapters, as well as `Filter`, `Map`, `Reduce`,
    `Find`, `Position`, and `Negate`. For more details, refer to `?Filter` in the
    documentation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数之外，R还提供了几个其他apply家族函数，正如我们在前面的章节中提到的，以及`Filter`、`Map`、`Reduce`、`Find`、`Position`和`Negate`。更多详细信息，请参阅文档中的`?Filter`。
- en: Moreover, the use of higher-order functions not only makes the code easier to
    read and more expressive, but these functions also separate the implementation
    of each level of abstraction so that they are independent from each other. It
    is much easier to improve simpler components than a whole bundle of logic coupled
    together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用高阶函数不仅使代码更容易阅读和表达，而且这些函数还分离了每个抽象级别的实现，使它们相互独立。比一个逻辑耦合的整体更容易改进简单的组件。
- en: For example, we can use apply-family functions to perform vector mapping, given
    a function. If each iteration is independent from the others, we can parallelize
    the mapping using multiple CPU cores so that more tasks can be done simultaneously.
    However, if we didn't use higher-order functions at the first place but a for-loop
    instead, it would take a while to convert it to parallel code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 apply-family 函数执行向量映射，给定一个函数。如果每个迭代与其他迭代独立，我们可以使用多个 CPU 核心并行化映射，以便同时执行更多任务。然而，如果我们最初没有使用高阶函数，而是使用
    for 循环，那么将其转换为并行代码需要一段时间。
- en: 'For example, let''s assume we use a for-loop to get the results. In each iteration,
    we perform a heavy computing task. Even if we find each iteration independently
    from the others, it is not always straightforward to convert it to parallel code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们使用 for 循环来获取结果。在每次迭代中，我们执行一个繁重的计算任务。即使我们发现每个迭代与其他迭代独立，也不总是容易将其转换为并行代码：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, if we use the higher-order function `lapply()`, things will be much
    easier:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用高阶函数 `lapply()`，事情将会简单得多：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It would just take one small change to transform the code into a parallel version.
    Using `parallel::mclapply()`, we can apply `f` to each element of `x` with multiple
    cores:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只需对代码进行一点小的修改，就可以将其转换为并行版本。使用 `parallel::mclapply()`，我们可以使用多个核心将 `f` 应用到 `x`
    的每个元素上：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unfortunately, `mclapply()` does not support Windows. More code is needed to
    perform parallel apply functions in Windows. We will cover this topic in the chapter
    on high-performance computing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，`mclapply()` 不支持 Windows 系统。在 Windows 上执行并行应用函数需要更多的代码。我们将在高性能计算章节中介绍这个话题。
- en: Computing on language
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言上的计算
- en: In the previous section, we introduced the functional programming facilities
    in R. You learned that functions are just another type of object we can pass around.
    When we create a new function, say `fun`, the environment we create will be associated
    with the function. This environment is called the enclosing environment of the
    function, which can be accessed via `environment(fun)`. Each time we call the
    function, a new executing environment that contains the unevaluated arguments
    (promises) will be created to host the execution of the function, which enables
    lazy evaluation. The parent of the executing environment is the enclosing environment
    of the function, which enables lexical scoping.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了 R 中的函数式编程设施。你了解到函数只是我们可以传递的另一种类型的对象。当我们创建一个新的函数，比如 `fun`，我们创建的环境将与该函数相关联。这个环境被称为函数的封装环境，可以通过
    `environment(fun)` 访问。每次我们调用函数时，都会创建一个新的执行环境，该环境包含未评估的参数（承诺），以托管函数的执行，这实现了惰性求值。执行环境的父环境是函数的封装环境，这实现了词法作用域。
- en: Functional programming allows us to write code in higher level of abstraction.
    Metaprogramming goes even further. It allows us to tweak the language itself and
    make certain language constructs easier to use in a certain scenario. Some popular
    R packages use metaprogramming in their functions to make things easier. In this
    section, I will show you the power of metaprogramming as well as its pros and
    cons, so that you can understand how related packages and functions work.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程允许我们在更高的抽象级别编写代码。元编程更进一步。它允许我们调整语言本身，并使某些语言结构在某些场景下更容易使用。一些流行的 R 包在其函数中使用元编程来简化事物。在本节中，我将向你展示元编程的力量以及其优缺点，以便你了解相关包和函数是如何工作的。
- en: Before digging into the knowledge of how things work, we may look at a few built-in
    functions that use metaprogramming to make things easier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解事物是如何工作的知识之前，我们可能先看看一些使用元编程来简化事物的内置函数。
- en: Suppose we want to filter the built-in dataset `iris` for records with each
    numeric column being greater than 80 percent of all records.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要过滤内置数据集 `iris`，以找到每个数值列都大于所有记录 80% 的记录。
- en: 'The standard method is to subset the rows of the data frame by composing a
    logical vector:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方法是通过对逻辑向量进行组合来对数据框的行进行子集化：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, each call of `quantile()` yields an 80 percent threshold
    for a column. Although the code works, it is quite redundant, because each time
    we use a column, we have to begin with `iris$`. In total, `iris$` appears nine
    times.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每次调用`quantile()`都会为一个列提供一个80%的阈值。尽管代码可以工作，但它相当冗余，因为每次我们使用一个列时，都必须以`iris$`开始。总共，`iris$`出现了九次。
- en: 'The built-in function `subset` is useful to make things easier:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`subset`非常有用，可以使事情变得更简单：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code returns exactly the same results, but with cleaner code.
    But why does it work while omitting `iris$` in the previous example does not work?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码返回了完全相同的结果，但代码更简洁。但为什么在先前的例子中省略`iris$`却不起作用呢？
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code does not work, because `Sepal.Length` and other columns are
    not defined in the scope (or environment) where we evaluate the subsetting expression.
    The magic function, `subset`, uses metaprogramming techniques to tweak the evaluation
    environment of its arguments so that `Sepal.Length>quantile(Sepal.Length, 0.8)`
    is evaluated in the environment with the columns of `iris`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码无法正常工作，因为`Sepal.Length`和其他列没有定义在我们评估子集表达式的范围（或环境）中。神奇的函数`subset`使用元编程技术调整其参数的评估环境，以便`Sepal.Length>quantile(Sepal.Length,
    0.8)`在`iris`的列的环境中评估。
- en: 'Moreover, `subset` not only works with rows, but is also useful in selecting
    columns. For example, we can also specify the `select` argument by directly using
    the column names as variables instead of using a character vector to select columns:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`subset`不仅与行一起工作，而且在选择列时也非常有用。例如，我们也可以通过直接使用列名作为变量来指定`select`参数，而不是使用字符向量来选择列：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See, `subset` tweaks how its second argument (`subset`) and third argument (`select`)
    are evaluated. The result is we can write simpler code with less redundancy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`subset`如何调整其第二个参数（`subset`）和第三个参数（`select`）的评估方式。结果是我们可以用更简洁的代码和更少的冗余来编写代码。
- en: In the next few sections, you will learn what happens behind the scene and how
    it is designed to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将了解幕后发生的事情以及它是如何设计的来工作的。
- en: Capturing and modifying expressions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和修改表达式
- en: 'When we type an expression and hit the *Enter* (or return) key, R will evaluate
    the expression and show the output. Here is an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入一个表达式并按下*Enter*（或回车）键时，R将评估该表达式并显示输出。以下是一个示例：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It shows the five random numbers generated. The magic of `subset` is that it
    tweaks the environment where the argument is evaluated. This happens in two steps:
    first, capture the expression and then, interfere the evaluation of the expression.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了生成的五个随机数。`subset`的神奇之处在于它调整了参数评估的环境。这分为两个步骤：首先捕获表达式，然后干扰表达式的评估。
- en: Capturing expressions as language objects
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将表达式作为语言对象捕获
- en: 'Capturing an expression means preventing the expression from being evaluated,
    but storing the expression itself as a variable. The function that does this is
    `quote()`; we can call `quote()` to capture the expression between the parenthesis:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获一个表达式意味着阻止表达式被评估，但将表达式本身存储为变量。执行此操作的是`quote()`函数；我们可以调用`quote()`来捕获括号之间的表达式：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code does not result in five random numbers, but the function
    call itself. We can use `typeof()` and `class()` to see the type and class of
    the resulted object, `call1`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码并没有产生五个随机数，而是函数调用本身。我们可以使用`typeof()`和`class()`来查看结果对象`call1`的类型和类：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see that `call1` is essentially a language object and it is a call.
    We can also write a function name in `quote()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`call1`本质上是一个语言对象，它是一个调用。我们也可以在`quote()`中写入一个函数名：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, we don't get a call but a symbol (or name) instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有得到一个调用，而是一个符号（或名称）。
- en: In fact, `quote()` will return a call if a function call is captured and return
    a symbol if a variable name is captured. The only requirement is the validity
    of the code to capture; that is, as long as the code is syntactically correct,
    `quote()` will return the language object that represents the captured expression
    itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果捕获了一个函数调用，`quote()`将返回一个调用，如果捕获了一个变量名，则返回一个符号。唯一的要求是捕获代码的有效性；也就是说，只要代码在语法上是正确的，`quote()`就会返回代表捕获表达式的语言对象。
- en: 'Even if the function does not exist or the variable as yet is undefined, the
    expression can be captured on its own:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使函数不存在或变量尚未定义，表达式也可以单独捕获：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Of the preceding language objects, maybe `pvar`, `xfun`, and `n` are all as
    yet undefined, but we can `quote()` them anyway.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语言对象中，可能 `pvar`、`xfun` 和 `n` 都尚未定义，但我们仍然可以 `quote()` 它们。
- en: It is important to understand the difference between a variable and a symbol
    object, and between a function and a call object. A variable is a name of an object,
    and a symbol object is the name itself. A function is an object that is callable,
    and a call object is a language object that represents such a function call, which
    is as yet unevaluated. In this case, `rnorm` is a function and it is callable
    (for example, `rnorm(5)` returns five random numbers), but `quote(rnorm)` returns
    a symbol object and `quote(rnorm(5))` returns a call object, both of which are
    only the representations of the language itself.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 理解变量和符号对象，以及函数和调用对象之间的区别是很重要的。变量是一个对象的名称，而符号对象是名称本身。函数是一个可调用的对象，而调用对象是一个表示这种函数调用的语言对象，它尚未评估。在这种情况下，`rnorm`
    是一个函数，它是可调用的（例如，`rnorm(5)` 返回五个随机数），但 `quote(rnorm)` 返回一个符号对象，而 `quote(rnorm(5))`
    返回一个调用对象，它们都只是语言本身的表示。
- en: 'We can convert the call object to a list so that we can see its internal structure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将调用对象转换为列表，这样我们就可以看到其内部结构：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This shows that the call consists of two components: the symbol of the function
    and one argument. We can extract objects from a call object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明调用由两个组件组成：函数的符号和一个参数。我们可以从调用对象中提取对象：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first element of `call1` is a symbol:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`call1` 的第一个元素是一个符号：'
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The second element of `call1` is a numeric value. From the previous examples,
    we know that `quote()` captures a variable name as a symbol object and a function
    call as a call object. Both of them are language objects. Like typical data structures,
    we can use `is.symbol()`/`is.name()` and `is.call()` to detect whether an object
    is a symbol or a call, respectively. More generally, we can also use `is.language()`
    to detect both the symbol and the call.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`call1` 的第二个元素是一个数值。从前面的例子中，我们知道 `quote()` 将变量名称捕获为符号对象，将函数调用捕获为调用对象。它们都是语言对象。像典型数据结构一样，我们可以使用
    `is.symbol()`/`is.name()` 和 `is.call()` 来检测一个对象是否是符号或调用，更普遍地，我们也可以使用 `is.language()`
    来检测符号和调用。'
- en: 'Another question is, "What if we call `quote()` on a literal value? What about
    a number or a string?" The following code creates a numeric value `num1` and a
    quoted numeric value `num2`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题，“如果我们对字面值调用 `quote()` 会怎样？如果是数字或字符串呢？”以下代码创建了一个数值 `num1` 和一个引用的数值 `num2`：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'They have exactly the same representation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有完全相同的表示：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In fact, they have exactly the same value:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它们的值完全相同：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Therefore, `quote()` does not transform a literal value (such as a number,
    logical value, string, and so on) to a language object, but it leaves it as it
    is. However, an expression that combines several literal values into a vector
    will still be transformed into a call object. Here is an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`quote()` 并不会将字面值（如数字、逻辑值、字符串等）转换为语言对象，而是保持原样。然而，将几个字面值组合成向量的表达式仍然会被转换为调用对象。以下是一个例子：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It is consistent because `c()` is indeed a function that combines values and
    vectors. Moreover, if you look at the list representation of the call using `as.list()`,
    we can see the structure of the call:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一致的，因为 `c()` 确实是一个结合值和向量的函数。此外，如果你使用 `as.list()` 查看调用列表的表示，我们可以看到调用的结构：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The types of elements in the call can be revealed by `str()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调用中元素的类型可以通过 `str()` 来揭示：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Another noteworthy fact here is that simple arithmetic calculations are captured
    as calls too because they are surely function calls to arithmetic operators such
    as `+` and `*`, which are essentially built-in functions. For example, we can
    use the `quote()` function to the simplest arithmetic calculation, perform `1
    + 1`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的事实是，简单的算术计算也被捕获为调用，因为它们肯定是算术运算符（如 `+` 和 `*`）的函数调用，这些运算符本质上都是内置函数。例如，我们可以使用
    `quote()` 函数对最简单的算术计算进行操作，执行 `1 + 1`：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The arithmetic representation is preserved, but it is a call and has exactly
    the same structure as of a call:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运算表示被保留，但它是一个调用，并且具有与调用完全相同的结构：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Given all the preceding knowledge about capturing an expression, we can now
    capture a nested call; that is, a call that contains more calls:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了所有关于捕获表达式的知识之后，我们现在可以捕获嵌套调用；也就是说，一个包含更多调用的调用。
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can use a function in the `pryr` package to view the recursive structure
    of the call. To install the package, run `install.package("pryr")`. Once the package
    is ready, we can call `pryr::call_tree` to do that:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `pryr` 包中的函数来查看调用的递归结构。要安装该包，运行 `install.package("pryr")`。一旦包准备就绪，我们可以调用
    `pryr::call_tree` 来实现：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For `call4`, the recursive structure is printed in a tree structure. The `\-
    ()` operator means a call, then `` `var `` represents a symbol object `var`, and
    others are literal values. In the preceding output, we can see that symbols and
    calls are captured and literal values are preserved.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `call4`，递归结构以树状结构打印。`\- ()` 操作符表示一个调用，然后 `` `var `` 表示一个符号对象 `var`，其余的是文字值。在前面的输出中，我们可以看到符号和调用被捕获，而文字值被保留。
- en: If you are curious about the call tree of an expression, you can always use
    this function because it precisely reflects the way R processes the expression.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇一个表达式的调用树，你总是可以使用这个函数，因为它精确地反映了 R 处理表达式的方式。
- en: Modifying expressions
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改表达式
- en: 'When we capture an expression as a call object, the call can be modified as
    if it were a list. For example, we can change the function to call by replacing
    the first element of the call with another symbol:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将表达式捕获为调用对象时，调用可以像列表一样进行修改。例如，我们可以通过将调用的第一个元素替换为另一个符号来更改要调用的函数：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, `rnorm(5)` is changed to `runif(5)`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`rnorm(5)` 被更改为 `runif(5)`。
- en: 'We can also add new argument to the call:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向调用中添加新参数：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Then, the call now has another parameter: `min = -1`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用现在有另一个参数：`min = -1`。
- en: Capturing expressions of function arguments
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获函数参数的表达式
- en: In the previous examples, you learned how to use `quote()` to capture a known
    expression, but `subset` works with arbitrary user-input expressions. Suppose
    we want to capture the expression of argument `x`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你学习了如何使用 `quote()` 捕获已知表达式，但 `subset` 与任意用户输入的表达式一起工作。假设我们想捕获参数 `x`
    的表达式。
- en: 'The first implementation uses `quote()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种实现使用 `quote()`：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s see if `fun1` can capture the input expression when we call the function
    with `rnorm(5)`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当使用 `rnorm(5)` 调用函数时，`fun1` 是否可以捕获输入表达式：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Obviously, `quote(x)` only captures `x` and has nothing to do with the input
    expression `rnorm(5)`. To correctly capture it, we need to use `substitute()`.
    The function captures an expression and substitutes existing symbols with their
    expressions. The simplest usage of this function is to capture the expression
    of a function argument:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`quote(x)` 只捕获 `x`，与输入表达式 `rnorm(5)` 没有关系。为了正确捕获它，我们需要使用 `substitute()`。该函数捕获一个表达式，并用它们的表达式替换现有符号。此函数的最简单用法是捕获函数参数的表达式：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With this implementation, `fun2` returns the input expression rather than `x`
    because `x` is replaced with the input expression, in this case, `rnorm(5)`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现，`fun2` 返回输入表达式而不是 `x`，因为 `x` 被替换为输入表达式，在这种情况下，`rnorm(5)`。
- en: 'The following examples demonstrate the behavior of `substitute` when we supply
    a list of language objects or literal values. In the first example, we substitute
    each symbol `x` in the given expression with `1`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了当我们提供一个语言对象或文字值的列表时，`substitute` 的行为。在第一个示例中，我们将给定表达式中每个符号 `x` 替换为 `1`：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the second example, we substitute each symbol `f` that is supposed to be
    a function name with another quoted function name `sin`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将应该作为函数名的每个符号 `f` 替换为另一个引用函数名 `sin`：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, we are able to capture a certain expression with `quote()` and user-input
    expression with `substitute()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够使用 `quote()` 捕获某些表达式，并使用 `substitute()` 捕获用户输入的表达式。
- en: Constructing function calls
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数调用
- en: 'In addition to capturing expressions, we can directly build language objects
    with built-in functions. For example, `call1` is a captured call using `quote()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了捕获表达式外，我们还可以直接使用内置函数构建语言对象。例如，`call1` 是使用 `quote()` 捕获的调用：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can use `call()` to create a call of the same function with the same arguments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `call()` 创建具有相同参数的相同函数的调用：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, we can convert a list of call components to a call using `as.call()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `as.call()` 将调用组件列表转换为调用：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The three methods create identical calls; that is, they call a function of
    the same name and with the same arguments, which can be confirmed by calling `identical()`
    with the three resulted call objects:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法创建相同的调用；也就是说，它们调用具有相同名称和相同参数的函数，这可以通过使用 `identical()` 调用三个结果调用对象来确认：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Evaluating expressions
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估表达式
- en: After capturing an expression, the next step is evaluating it. This can be done
    with `eval()`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获一个表达式之后，下一步是评估它。这可以通过`eval()`函数来完成。
- en: 'For example, if we type `sin(1)` and enter, the value will appear immediately:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们输入`sin(1)`并回车，值将立即显示：
- en: '[PRE66]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To control the evaluation of `sin(1)`, We can use `quote()` to capture the
    expression and then `eval()` to evaluate the function call:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制`sin(1)`的评估，我们可以使用`quote()`来捕获表达式，然后使用`eval()`来评估函数调用：
- en: '[PRE67]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can capture any expression that is syntactically correct, which allows us
    to `quote()` an expression that uses undefined variables:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获任何语法正确的表达式，这允许我们`quote()`一个使用未定义变量的表达式：
- en: '[PRE68]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In `call2`, `sin(x)` uses an undefined variable `x`. If we directly evaluate
    it, an error occurs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`call2`中，`sin(x)`使用了一个未定义的变量`x`。如果我们直接评估它，将发生错误：
- en: '[PRE69]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This error is similar to what happens when we directly run `sin(x)` without
    `x` being defined:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误类似于当我们直接运行未定义的`x`的`sin(x)`时发生的情况：
- en: '[PRE70]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The difference between directly running in console and using `eval()` is that
    `eval()` allows us to provide a list to evaluate the given expression. In this
    case, we don''t have to create a variable `x` but supply a temporary list that
    contains `x` so that the expression will look up symbols in the list:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在控制台运行和使用`eval()`之间的区别在于`eval()`允许我们提供一个列表来评估给定的表达式。在这种情况下，我们不需要创建变量`x`，而是提供一个包含`x`的临时列表，这样表达式就可以在列表中查找符号：
- en: '[PRE71]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Alternatively, `eval()` also accepts an environment for symbol lookup. Here,
    we will create a new environment `e1` in which we create a variable `x` with value
    `1`, and then we use `eval()` in the call in `e1`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`eval()`函数也接受一个用于符号查找的环境。在这里，我们将创建一个新的环境`e1`，在其中我们创建一个值为`1`的变量`x`，然后我们在`e1`中的调用中使用`eval()`：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The same logic also applies when the captured expression has more undefined
    variables:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获的表达式有更多未定义变量时，同样的逻辑也适用：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Directly evaluating the expression without a complete specification of the
    undefined symbols will result in an error:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有完全指定未定义符号的表达式，直接评估表达式将导致错误：
- en: '[PRE74]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'So does a partial specification, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 部分指定也是如此：
- en: '[PRE75]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Only when we fully specify the values of the symbols in the expression can
    the evaluation result in a value:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们完全指定表达式中的符号值时，评估才能得到一个值：
- en: '[PRE76]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The evaluation model of `eval(expr, envir, enclos)` is the same as calling a
    function. The function body is `expr`, and the executing environment is `envir`.
    If `envir` is given as a list, then the enclosing environment is `enclos`, or
    otherwise the enclosing environment is the parent environment of `envir`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval(expr, envir, enclos)`的评估模型与调用函数相同。函数体是`expr`，执行环境是`envir`。如果`envir`被给定为列表，则封装环境是`enclos`，否则封装环境是`envir`的父环境：'
- en: 'This model implies the exact behavior of symbol lookup. Suppose we use an environment
    instead to evaluate `call3`. Since `e1` only contains variable `x`, the evaluation
    does not proceed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型意味着符号查找的确切行为。假设我们使用一个环境来评估`call3`。由于`e1`只包含变量`x`，评估不会继续：
- en: '[PRE77]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we create a new environment whose parent is `e1` and contains variable
    `y`. If we now evaluate `call3` in `e2`, both `x` and `y` are found and the evaluation
    works:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的环境，其父环境是`e1`并包含变量`y`。如果我们现在在`e2`中评估`call3`，`x`和`y`都被找到，评估工作正常：
- en: '[PRE78]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the preceding code, `eval(call3, e2)` tries to evaluate `call3`, with `e2`
    being the executing environment. Now, we can go through the evaluating process
    to get a better understanding of how it works. The evaluation process is reflected
    by travelling recursively along the call tree produced by `pryr::call_tree()`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`eval(call3, e2)`尝试评估`call3`，其中`e2`是执行环境。现在，我们可以通过评估过程来更好地理解它是如何工作的。评估过程通过`pryr::call_tree()`产生的调用树递归地反映出来：
- en: '[PRE79]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First, it tries to find a function called `+`. It goes through `e2` and `e1`,
    and does not find `+` until it reaches the base environment (`baseenv()`), where
    all the basic arithmetic operators are defined. Then, `+` needs to evaluate its
    arguments, so it looks for another function called `^` and finds it by going through
    the same flow. Then, again `^` needs to evaluate its arguments, so it looks for
    symbol `x` in `e2`. Environment `e2` does not contain variable `x`, so it continues
    searching in `e2` class's parent environment, `e1`, and finds `x` there. Finally,
    it looks for symbol `y` in `e2` and finds it immediately. When the arguments a
    call needs are ready, the call can be evaluated to a result.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它试图找到一个名为 `+` 的函数。它遍历 `e2` 和 `e1`，直到达到基础环境（`baseenv()`），在那里定义了所有基本算术运算符，才找到
    `+`。然后，`+` 需要评估其参数，因此它寻找另一个名为 `^` 的函数，并通过相同的流程找到它。然后，`^` 再次需要评估其参数，因此它寻找 `e2`
    中的符号 `x`。环境 `e2` 不包含变量 `x`，因此它继续在 `e2` 类的父环境 `e1` 中搜索，并在那里找到 `x`。最后，它在 `e2` 中寻找符号
    `y` 并立即找到它。当调用所需的参数准备就绪时，调用可以评估为结果。
- en: 'An alternative approach is to supply a list to `envir` and an enclosing environment:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是向 `envir` 提供一个列表和一个封装的环境：
- en: '[PRE80]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The evaluating process begins with an executing environment generated from the
    list whose parent environment is `e3`, as specified. Then, the process is exactly
    the same as the previous example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 评估过程从从列表生成的执行环境开始，其父环境是按指定方式指定的 `e3`。然后，过程与前面的示例完全相同。
- en: Since everything we do is essentially calling functions, `quote()` and `substitute()`
    can capture everything, including assignment and other operations that do not
    look like calling functions. In fact, for example, `x <- 1` is essentially calling
    `<-` with `(x, 1)`, and `length(x) <- 10` is essentially calling `length<-` with
    `(x, 10)`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们做的所有事情本质上都是调用函数，`quote()` 和 `substitute()` 可以捕获一切，包括赋值和其他看起来不像调用函数的操作。事实上，例如，`x
    <- 1` 实质上是调用 `<-` 并传递 `(x, 1)`，而 `length(x) <- 10` 实质上是调用 `length<-` 并传递 `(x,
    10)`。
- en: To demonstrate the point, we may construct another example in which we create
    a new variable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可能构造另一个示例，其中我们创建一个新的变量。
- en: 'In the following example, we supply a list to generate the executing environment
    and `e3` as the enclosing environment:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们提供一个列表来生成执行环境，并将 `e3` 作为封装环境：
- en: '[PRE81]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As a result, `z` is not created in `e3` but in a temporary executing environment
    created from the list. If we, instead, specify `e3` as the executing environment,
    the variable will be created in it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`z` 不会在 `e3` 中创建，而是在从列表创建的临时执行环境中创建。如果我们，相反，指定 `e3` 作为执行环境，变量将在其中创建：
- en: '[PRE82]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In conclusion, `eval()` works in a way extremely close to the behavior of function
    calling, but `eval()` allows us to customize the evaluation of an expression by
    tweaking its executing and enclosing environment, which allows us to do good things
    such as `subset` as well as bad things such as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`eval()` 的工作方式与函数调用的行为极为相似，但 `eval()` 允许我们通过调整其执行和封装环境来自定义表达式的评估，这使我们能够做一些好事，比如
    `subset`，以及一些坏事，如下所示：
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Understanding non-standard evaluation
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解非标准评估
- en: In the previous sections, you learned how to use `quote()` and `substitute()`
    to capture an expression as a language object, and you learned how to use `eval()`
    to evaluate it within a given list or environment. These functions constitute
    the facility of metaprogramming in R and allow us to tweak standard evaluation.
    The main application of metaprogramming is to perform non-standard evaluation
    to make certain usage easier. In the following sections, we will discuss a few
    examples to gain a better understanding of how it works.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用 `quote()` 和 `substitute()` 来捕获一个表达式作为语言对象，以及如何使用 `eval()` 在给定的列表或环境中评估它。这些函数构成了
    R 中的元编程功能，允许我们调整标准评估。元编程的主要应用是执行非标准评估，以使某些使用更加容易。在接下来的章节中，我们将讨论一些示例，以更好地理解它是如何工作的。
- en: Implementing quick subsetting using non-standard evaluation
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用非标准评估实现快速子集选择
- en: Often, we need to take out a certain subset from a vector. The range of the
    subset may be the first few elements, last few elements, or some elements in the
    middle.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要从一个向量中提取某个子集。子集的范围可能是前几个元素，最后几个元素，或者中间的一些元素。
- en: The first two cases can be easily handled by `head(x, n)` and `tail(x, n)`.
    The third case requires an input of the length of the vector.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种情况可以通过 `head(x, n)` 和 `tail(x, n)` 容易地处理。第三种情况需要输入向量的长度。
- en: 'For example, suppose we have an integer vector and want to take out elements
    from the third to the fifth last:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个整数向量，并想要取出从第三个到最后第五个的元素：
- en: '[PRE84]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding subsetting expression uses `x` twice and looks a bit redundant.
    We can define a quick subsetting function that uses metaprogramming facilities
    to provide a special symbol to refer to the length of the input vector The following
    function, `qs`, is a simple implementation of this idea that allows us to use
    dot (`.`) to represent the length of the input vector `x`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的子集表达式使用了 `x` 两次，看起来有点冗余。我们可以定义一个快速子集函数，它使用元编程功能提供一个特殊符号来引用输入向量的长度。以下函数 `qs`
    是这个想法的简单实现，它允许我们使用点 (`.`) 来表示输入向量 `x` 的长度：
- en: '[PRE85]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Using this function, we can use `3:(. - 5)` to represent the same range as
    the motivating example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以用 `3:(. - 5)` 来表示与激励示例相同的范围：
- en: '[PRE86]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can also easily pick out a number by counting from the last element:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以很容易地通过从最后一个元素开始计数来挑选出一个数字：
- en: '[PRE87]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Based on `qs()`, the following function is designed to trim both margins of
    `n` elements from the input vector `x`; that is, it returns a vector without the
    first `n` and last `n` elements of `x`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `qs()`，以下函数被设计用来从输入向量 `x` 中修剪 `n` 个元素的边缘；也就是说，它返回一个没有 `x` 的第一个 `n` 个和最后一个
    `n` 个元素的向量：
- en: '[PRE88]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The function looks alright, but when we call it with an ordinary input, an
    error occurs:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 函数看起来没问题，但当我们用普通输入调用它时，会发生错误：
- en: '[PRE89]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How come it couldn't find `n`? To understand why this happens, we need to analyze
    the path of symbol lookup when `trim_margin` is called. In the next section, we
    will go into this in detail and introduce the concept of dynamic scoping to resolve
    the problem.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么找不到 `n`？为了理解为什么会发生这种情况，我们需要分析 `trim_margin` 被调用时符号查找的路径。在下一节中，我们将详细讨论这个问题，并介绍动态作用域的概念来解决该问题。
- en: Understanding dynamic scoping
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解动态作用域
- en: Before trying to tackle the problem, let's use what you have learned to analyze
    what went wrong. When we call `trim_margin(x, 3)`, we call `qs(x, (n + 1):(. -
    n - 1))` in a fresh executing environment with `x`, and `n`. `qs()` is special
    because it uses non-standard evaluation. More specifically, it first captures
    `range` as a language object and then evaluates it with a list of additional symbols
    to provide, which, at the moment, only contains `. = length(x)`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试解决这个问题之前，让我们用你所学到的知识来分析发生了什么错误。当我们调用 `trim_margin(x, 3)` 时，我们在一个新的执行环境中调用
    `qs(x, (n + 1):(. - n - 1))`，并带有 `x` 和 `n`。`qs()` 是特殊的，因为它使用非标准评估。更具体地说，它首先将 `range`
    作为语言对象捕获，然后使用一个包含要提供的额外符号的列表来评估它，此时，这个列表只包含 `. = length(x)`。
- en: 'The error just happens at `eval(range, list(. = length(x)))`. The number of
    margin elements to trim, `n`, cannot be found here. There must be something wrong
    with the enclosing environment of evaluation. Now, we will take a closer look
    at the default value of the `enclos` argument of `eval()`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 错误刚好发生在 `eval(range, list(. = length(x)))`。要修剪的边缘元素数量 `n` 在这里找不到。评估的包围环境肯定有问题。现在，我们将更仔细地查看
    `eval()` 函数的 `enclos` 参数的默认值：
- en: '[PRE90]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The definition of `eval()` says that if we supply a list to `envir`, which is
    exactly what we have done, `enclos` will take `parent.frame()` by default, which
    is the calling environment of `eval()`; that is, the executing environment when
    we call `qs()`. Certainly, there is no `n` in any executing environment of `qs`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()` 的定义说明，如果我们向 `envir` 提供一个列表，这正是我们所做的，`enclos` 将默认取 `parent.frame()`，即
    `eval()` 的调用环境；也就是说，当我们调用 `qs()` 时执行的 环境。当然，`qs()` 的任何执行环境中都没有 `n`。'
- en: Here, we exposed a shortcoming of using `substitute()` in `trim_margin()` because
    the expression is only fully meaningful in the correct context, that is, the executing
    environment of `trim_margin()`, which is also the calling environment of `qs()`.
    Unfortunately, `substitute()` only captures the expression; it does not capture
    the environment in which the expression is meaningful. Therefore, we have to do
    it ourselves.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们暴露了在 `trim_margin()` 中使用 `substitute()` 的一个缺点，因为表达式只有在正确的上下文中才有完全的意义，即
    `trim_margin()` 的执行环境，也是 `qs()` 的调用环境。不幸的是，`substitute()` 只捕获表达式；它不捕获表达式有意义的上下文。因此，我们必须自己来做这件事。
- en: 'Now, we know where the problem comes from. The solution is simple: always use
    the correct enclosing environment in which the captured expression is defined.
    In this case, we specify `enclos = parent.frame()` so that `eval()` looks for
    all symbols other than `.` in the calling environment of `qs()`, that is, the
    executing environment of `trim_margin()` where `n` is supplied.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道问题出在哪里了。解决方案很简单：始终使用捕获表达式定义的正确封装环境。在这种情况下，我们指定 `enclos = parent.frame()`，这样
    `eval()` 就会在 `qs()` 的调用环境中寻找所有除 `.` 之外的符号，即 `trim_margin()` 的执行环境，其中提供了 `n`。
- en: 'The following lines of code are the fixed version of `qs()`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是 `qs()` 的固定版本：
- en: '[PRE91]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can test the function with the same code that went wrong previously:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用之前出错的相同代码测试这个函数：
- en: '[PRE92]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, the function works in the correct manner. In fact, this mechanism is the
    so-called **dynamic scoping**. Recall what you learned in the previous chapter.
    Each time a function is called, an executing environment is created. If a symbol
    cannot be found in the executing environment, it will search the enclosing environment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数以正确的方式工作。实际上，这种机制就是所谓的**动态作用域**。回想一下你在上一章中学到的内容。每次函数被调用时，都会创建一个执行环境。如果一个符号在执行环境中找不到，它将搜索封装环境。
- en: With lexical scoping used in standard evaluation, the enclosing environment
    of a function is determined when the function is defined and so is the environment
    where it is defined.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准评估中使用的词法作用域中，函数的封装环境在函数定义时确定，其定义的环境也是如此。
- en: However, with dynamic scoping used in non-standard evaluation, by contrast,
    the enclosing environment should be the calling environment in which the captured
    expression is defined so that symbols can be found either in the customized executing
    environment or in the enclosing environment, along with its parents.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与在非标准评估中使用的动态作用域相比，封装环境应该是捕获表达式定义的调用环境，以便符号可以在自定义执行环境或封装环境中找到，包括其父环境。
- en: In conclusion, when a function uses non-standard evaluation, it is important
    to ensure that dynamic scoping is correctly implemented.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当一个函数使用非标准评估时，确保动态作用域正确实现是非常重要的。
- en: Using formulas to capture expression and environment
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用公式捕获表达式和环境
- en: To correctly implement dynamic scoping, we use `parent.frame()` to track the
    expression captured by `substitute()`. An easier way is to use a formula to capture
    the expression and environment at the same time.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正确实现动态作用域，我们使用 `parent.frame()` 来追踪 `substitute()` 捕获的表达式。一个更简单的方法是使用公式同时捕获表达式和环境。
- en: In the chapter of working the data, we saw that a formula is often used to represent
    the relationship between variables. Most model functions (such as `lm()`) accept
    a formula to specify the relationship between a response variable and explanatory
    variables.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理章节中，我们看到了公式通常用来表示变量之间的关系。大多数模型函数（如 `lm()`）接受一个公式来指定响应变量和解释变量之间的关系。
- en: 'In fact, a formula object is much simpler than that. It automatically captures
    the expressions beside `~` and the environment where it is created. For example,
    we can directly create a formula and store it in a variable:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，公式对象比这要简单得多。它自动捕获 `~` 旁边的表达式及其创建的环境。例如，我们可以直接创建一个公式并将其存储在一个变量中：
- en: '[PRE93]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can see that the formula is essentially a language object with the `formula`
    class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，公式本质上是一个具有 `formula` 类的语言对象：
- en: '[PRE94]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we convert the formula to a list, we can have a closer look at its structure:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将公式转换为列表，我们可以更仔细地查看其结构：
- en: '[PRE95]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can see that `formula1` captured not only the expressions as language objects
    on both sides of `~`, but also the environment where it was created. In fact,
    a formula is merely a call of function `~` with the arguments and calling environment
    captured. If both sides of `~` are specified, the length of the call is `3`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`formula1` 不仅捕获了 `~` 两边的语言对象表达式，还捕获了其创建的环境。实际上，一个公式仅仅是捕获了参数和调用环境的 `~`
    函数调用。如果 `~` 的两边都指定了，调用的长度是 `3`：
- en: '[PRE96]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To access the language objects it captured, we can extract the second and the
    third elements:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问它捕获的语言对象，我们可以提取第二个和第三个元素：
- en: '[PRE97]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To access the environment where it was created, we can call `environment()`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问其创建的环境，我们可以调用 `environment()`：
- en: '[PRE98]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'A formula can also be right-sided, that is, only the right side of `~` is specified.
    Here is an example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 公式也可以是右侧的，即只指定 `~` 的右侧。以下是一个例子：
- en: '[PRE99]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In this case, only one argument of `~` is supplied and captured so that we
    have a call of two language objects and we can access the expression it captured
    by extracting its second element:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只提供了一个`~`的参数并捕获了它，因此我们有两个语言对象的调用，我们可以通过提取其第二个元素来访问它捕获的表达式：
- en: '[PRE100]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: With the knowledge of how the formula works, we can implement another version
    of `qs()` and `trim_margin()` using the formula.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了公式的运作方式，我们可以使用该公式实现`qs()`和`trim_margin()`的另一个版本。
- en: 'The following function, `qs2`, behaves consistently with `qs` when `range`
    is a formula, or otherwise, it directly uses `range` to subset `x`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数`qs2`在`range`是公式时与`qs`的行为一致，否则它直接使用`range`来子集`x`：
- en: '[PRE101]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Note that we use `inherits(range, "formula")` to check whether `range` is a
    formula and use `environment(range)` to implement dynamic scoping. Then, we can
    use a right-sided formula to activate non-standard evaluation:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`inherits(range, "formula")`来检查`range`是否是公式，并使用`environment(range)`来实现动态作用域。然后，我们可以使用右侧公式来激活非标准评估：
- en: '[PRE102]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Otherwise, we can use standard evaluation:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以使用标准评估：
- en: '[PRE103]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we can re-implement `trim_margin` with `qs2` using a formula:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用公式重新实现`trim_margin`，使用`qs2`：
- en: '[PRE104]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'As can be verified, dynamic scoping works correctly because the formula used
    in `trim_margin2` automatically captures the executing environment, which is also
    the environment where the formula and `n` are defined:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可以验证，动态作用域工作正常，因为`trim_margin2`中使用的公式自动捕获执行环境，这也是公式和`n`定义的环境：
- en: '[PRE105]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Implementing subset with metaprogramming
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用元编程实现子集
- en: With the knowledge of language objects, evaluation functions, and dynamic scoping,
    now we have the capability to implement a version of `subset`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了语言对象、评估函数和动态作用域之后，我们现在有能力实现`subset`的一个版本。
- en: 'The underlying idea of the implementation is simple:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的底层思想很简单：
- en: Capture the row subsetting expression and evaluate it within the data frame
    which is, in essence, a list
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获行子集表达式，并在本质上是一个列表的数据框内评估它：
- en: Capture the column-selecting expression and evaluate it in a named list of integer
    indices
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获列选择表达式，并在命名整数索引列表中评估它：
- en: Use the resulting row selector (logical vector) and column selector (integer
    vector) to subset the data frame
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成的行选择器（逻辑向量）和列选择器（整数向量）来子集数据框：
- en: 'Here is an implementation of the preceding logic:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面逻辑的实现：
- en: '[PRE106]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The feature of row subsetting is easier to implement than the column selecting
    part. To perform row subsetting, we only need to capture `subset` and evaluate
    it within the data frame.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 行子集的功能比列选择部分更容易实现。要执行行子集，我们只需要捕获`subset`并在数据框内评估它。
- en: The column subsetting is trickier here. We will create a list of integer indices
    for the columns and give them the corresponding names. For example, a data frame
    with three columns (say, `x`, `y`, and `z`) needs a list of indices such as `list(a
    = 1, b = 2, c = 3)`, which allows us to select rows in the form of `select = c(x,
    y)` because `c(x, y)` is evaluated within the list.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，列子集更复杂。我们将创建一个整数索引列表，并为它们提供相应的名称。例如，具有三列（例如，`x`、`y`和`z`）的数据框需要一个索引列表，如`list(a
    = 1, b = 2, c = 3)`，这允许我们以`select = c(x, y)`的形式选择行，因为`c(x, y)`是在列表内评估的。
- en: 'Now, the behavior of `subset2` is very close to the built-in function `subset`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`subset2`的行为与内置函数`subset`非常接近：
- en: '[PRE107]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Both implementations allow us to use `a:b` to select all columns between `a`
    and `b`, including both sides:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现都允许我们使用`a:b`来选择`a`和`b`之间的所有列，包括两边：
- en: '[PRE108]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the idea and usage of functional programming,
    including closures and higher order functions. We went further by digging into
    the metaprogramming facilities, including language objects, evaluation functions,
    formula, and the implementation of dynamic scoping to ensure user-input expressions
    are correctly handled when we customize the evaluation behavior. Since a number
    of popular packages use metaprogramming and non-standard evaluation to make interactive
    analysis easier, it is important to understand how it works so that we can be
    more confident to predict and debug the code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了函数式编程的概念和用法，包括闭包和高阶函数。我们进一步深入研究了元编程功能，包括语言对象、评估函数、公式以及动态作用域的实现，以确保在自定义评估行为时正确处理用户输入的表达式。由于许多流行的包使用元编程和非标准评估来简化交互式分析，因此了解其工作原理非常重要，这样我们才能更有信心预测和调试代码。
- en: 'In the next chapter, we will walk into another infrastructure of R: the object-oriented
    programming systems. You will learn the basic idea of object-oriented programming,
    how this idea is implemented in R, and how it can be useful. More specifically,
    we will begin with the looser S3 system, cover the stricter system S4 which offers a
    richer set of features, and introduce the reference class and newly implemented
    R5 system.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将步入 R 的另一个基础设施：面向对象编程系统。你将学习面向对象编程的基本理念，这一理念如何在 R 中实现，以及它如何有用。更具体地说，我们将从较为宽松的
    S3 系统开始，涵盖提供更丰富功能的严格系统 S4，并介绍参考类以及新实现的 R5 系统。
