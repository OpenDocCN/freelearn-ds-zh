- en: 9 Calling External APIs to Enrich Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 调用外部API以丰富您的数据
- en: In the previous chapter, you saw an example of how to enrich the data you already
    have with external information. In that instance, the data was provided via CSV
    files, but this is not always the case. Very often, the data useful for enrichment
    is exposed via external **Application Programming Interfaces** (**APIs**), most
    frequently in the form of web service endpoints. Power BI allows you to read data
    from a web service via a dedicated UI, but most of the time it is unusable. Therefore,
    you have to resort to writing **M code** to get it done. Writing M code isn't
    too difficult, but it’s not that straightforward either. You also have to be careful
    not to write code that leads to refresh issues when publishing the report to the
    Power BI service. Moreover, in Power BI, it is not possible to parallelize more
    than one call to the same web service in order to reduce waiting time when retrieving
    data. Adopting Python or R to get data from a web service solves all these issues
    very easily.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您看到了如何使用外部信息丰富您已有的数据的示例。在那个例子中，数据是通过CSV文件提供的，但这种情况并不总是如此。很多时候，用于丰富数据的有用数据是通过外部**应用程序编程接口**（**API**）暴露的，通常以网络服务端点形式存在。Power
    BI允许您通过专用UI从网络服务中读取数据，但大多数情况下它不可用。因此，您必须求助于编写**M代码**来完成这项工作。编写M代码并不太难，但也不是那么直接。您还必须小心不要编写在将报告发布到Power
    BI服务时会导致刷新问题的代码。此外，在Power BI中，无法并行调用同一网络服务以减少检索数据时的等待时间。采用Python或R从网络服务中获取数据可以非常容易地解决所有这些问题。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: What a web service is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是网络服务
- en: Registering for Bing Maps Web Services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册Bing Maps网络服务
- en: Geocoding addresses using Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行地址地理编码
- en: Geocoding addresses using R
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R进行地址地理编码
- en: Accessing web services using Power BI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Power BI访问网络服务
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2*, *Configuring R with
    Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您在计算机上已安装并配置好工作状态的互联网连接和**Power BI桌面版**。您必须已按照*第2章*、*配置Power BI中的R*和*第3章*、*配置Power
    BI中的Python*中概述的方式正确配置了R和Python引擎以及IDE。
- en: What a web service is
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是网络服务
- en: In the course of your work as an analyst, you may need to retrieve data through
    an API, exposed by a system within your network, for example. However, this is
    a rare case, since today almost all external data sources are exposed as **web
    services**, even within a company.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在您作为分析师的工作过程中，您可能需要通过您网络内的系统公开的API检索数据，例如。然而，这种情况很少见，因为如今几乎所有的外部数据源都作为**网络服务**公开，即使在公司内部也是如此。
- en: Web services are the most common and popular way of communicating information
    between heterogeneous information systems. A web service is basically a software
    module hosted on a server that is available over the internet to provide data
    to specific requests from a client.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是异构信息系统之间通信信息最常见和最受欢迎的方式。网络服务基本上是一个托管在服务器上的软件模块，通过互联网向客户端提供数据以响应特定的请求。
- en: 'There are mostly two types of design models for web services: **Simple Object
    Access Protocol** (**SOAP**) and **REpresentational State Transfer** (**REST**).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务的设计模型主要有两种：**简单对象访问协议**（**SOAP**）和**表示状态转移**（**REST**）。
- en: SOAP relies heavily on **XML** and defines a highly typed messaging structure
    through schemas. All messages exchanged between the service and the client are
    all encoded through **Web Service Definition Language** (**WSDL**), which, in
    turn, is based on the XML format. One of the most important aspects of WSDL is
    that it defines a binding contract between the service provider and each service
    consumer. Therefore, any change to the API involves a change to be made to the
    client. Nowadays, almost everything that matters runs on HTTP. But keep in mind
    that, in addition to HTTP, SOAP can take advantage of any other transport protocol
    (such as SMTP and TCP).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP严重依赖于**XML**，并通过模式定义了一个高度类型化的消息结构。服务与客户端之间交换的所有消息都是通过**网络服务定义语言**（**WSDL**）编码的，而WSDL是基于XML格式的。WSDL最重要的方面之一是它定义了服务提供者和每个服务消费者之间的绑定合同。因此，任何对API的更改都涉及到对客户端的更改。如今，几乎所有重要的事情都在HTTP上运行。但请记住，除了HTTP之外，SOAP还可以利用任何其他传输协议（如SMTP和TCP）。
- en: REST is becoming the default design model for all public APIs. It is an architecture
    that relies exclusively on the HTTP protocol (as opposed to SOAP). It doesn’t
    use WSDL contracts and is, therefore, more flexible and faster to implement. REST
    can handle data in any format, such as XML or YAML, but the most used is surely
    **JSON**. Unlike SOAP, which is function-driven, REST is very **data-driven**.
    It is for this reason that all web services used for data enrichment are **RESTful**
    (take a look at the references for more details) and can generate output in any
    format – not only JSON but also CSV, or **Really Simple Syndication** (**RSS**),
    for example! Basically, REST offers a lighter method of interacting with the service,
    using URLs in most cases to receive or send information. The exposed basic methods
    are `GET`, `POST`, `PUT`, and `DELETE`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST正在成为所有公共API的默认设计模型。它是一种完全依赖于HTTP协议（与SOAP相对）的架构。它不使用WSDL合约，因此更加灵活且易于实现。REST可以处理任何格式的数据，如XML或YAML，但最常用的无疑是**JSON**。与以功能驱动的SOAP不同，REST非常**数据驱动**。正因为如此，所有用于数据丰富化的Web服务都是**RESTful**（更多详情请参阅参考资料）并且可以生成任何格式的输出——不仅限于JSON，还有CSV，或者例如**真正简单的聚合**（**RSS**）等！基本上，REST提供了一种更轻量级的方法与服务交互，在大多数情况下使用URL来接收或发送信息。公开的基本方法有`GET`、`POST`、`PUT`和`DELETE`。
- en: 'Quite often, you will have heard about web service **endpoints**. In general,
    a web service works by accepting `GET` requests from the client and providing
    responses to them. Considering a REST API, an endpoint is a URL at which the web
    service can be accessed by a client application. A web service can provide more
    than one endpoint. If you consider **Bing Maps REST Services**, for example, the
    endpoint used for geocoding is as follows: `dev.virtualearth.net/REST/v1/Locations`.
    The one used instead to provide a route between two waypoints is this one: `dev.virtualearth.net/REST/v1/Routes`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能您已经听说过**Web服务端点**。一般来说，Web服务通过接受客户端的`GET`请求并提供响应来工作。考虑到REST API，端点是一个客户端应用程序可以访问Web服务的URL。一个Web服务可以提供多个端点。例如，如果您考虑**Bing
    Maps REST服务**，用于地理编码的端点如下：`dev.virtualearth.net/REST/v1/Locations`。用于提供两个航点之间路线的端点是这个：`dev.virtualearth.net/REST/v1/Routes`。
- en: Now that it's clear what a web service is and what the meaning of the technical
    terms that often come with it is, we can move on to showing you how to use a RESTful
    one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚什么是Web服务以及经常与之相关的技术术语的含义，我们可以继续向您展示如何使用RESTful的Web服务。
- en: Registering for Bing Maps Web Services
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册Bing Maps Web服务
- en: 'In this chapter, we will use Bing Maps Web Services as an example. Therefore,
    you need to create a free Bing Maps Basic Key via your Microsoft account. The
    necessary steps to do so are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以Bing Maps Web服务为例。因此，您需要通过您的Microsoft账户创建一个免费的Bing Maps Basic密钥。完成此操作的必要步骤如下：
- en: Go to [https://www.microsoft.com/en-us/maps/create-a-bing-maps-key](https://www.microsoft.com/en-us/maps/create-a-bing-maps-key),
    select the **Basic Key** option just after the main banner, and then click on
    **Get a free Basic key** button.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://www.microsoft.com/en-us/maps/create-a-bing-maps-key](https://www.microsoft.com/en-us/maps/create-a-bing-maps-key)，在主横幅之后选择**基本密钥**选项，然后点击**获取免费基本密钥**按钮。
- en: On the next **Welcome** page, click on **Sign in** and use your Microsoft Account
    to log in.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个**欢迎**页面，点击**登录**并使用您的Microsoft账户进行登录。
- en: On the next page, you will be notified that this is the first time your email
    is being used to authenticate in the **Bing Maps Dev Center**. Click on **Yes,
    let's create a new account** to create a new account.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页，您将被告知这是您第一次使用电子邮件在**Bing Maps开发者中心**进行身份验证。点击**是的，让我们创建一个新账户**以创建一个新账户。
- en: Enter your account details on the next page and click **Create**. After that,
    you’ll be logged in to the Dev Center, and you’ll see some claims on the page
    saying **Announcement** and **Important reminder**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页输入您的账户详情并点击**创建**。之后，您将登录到开发者中心，页面上会显示一些声明，如**公告**和**重要提醒**。
- en: On that page, under the **My account** menu, click on **My keys**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该页面上，在**我的账户**菜单下，点击**我的密钥**。
- en: You will be prompted with a form asking for a new key . Just fill the required
    fields, entering `geocoding-test` in the **Application name** field, and leaving
    `Basic` as **Key type** and `Dev/Test` as **Application type**. Then, click on
    **Create**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个表单，要求输入新的密钥。只需填写所需的字段，在**应用程序名称**字段中输入`geocoding-test`，并将**密钥类型**保留为**基本**，将**应用程序类型**保留为**开发/测试**。然后，点击**创建**。
- en: 'A page will appear to confirm that the key has been created, such as the following
    one:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个页面来确认密钥已创建，如下所示：
- en: '![Figure 9.1 – Bing Maps key confirmation](img/file227.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图9.1 – Bing Maps密钥确认](img/file227.png)'
- en: Figure 9.1 – Bing Maps key confirmation
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1 – Bing Maps密钥确认
- en: Click on **Show key** to see the key you’ll use in the next examples and copy
    it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示密钥**来查看你将在下一个示例中使用的密钥，并将其复制。
- en: 'Enter the following URL in your browser URL bar, replacing the `<your-bing-maps-api-key>`
    string with your key: [http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=<your-bing-maps-api-key>](http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=%3Cyour-bing-maps-api-key%3E).
    Then, press *Enter*.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器URL栏中输入以下URL，将`<your-bing-maps-api-key>`字符串替换为你的密钥：[http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=<your-bing-maps-api-key>](http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=%3Cyour-bing-maps-api-key%3E)。然后，按*Enter*键。
- en: 'Some browsers, such as Firefox, prettify JSON responses returned by web services.
    In your case, if all goes well, you should see a result such as the following:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些浏览器，如Firefox，会美化Web服务返回的JSON响应。在你的情况下，如果一切顺利，你应该看到如下结果：
- en: '![Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the
    browser](img/file228.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用Bing Maps Locations API通过浏览器进行的第一次地理编码](img/file228.png)'
- en: Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the
    browser
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用Bing Maps Locations API通过浏览器进行的第一次地理编码
- en: Great! You’ve just geocoded an address passed as a query parameter to the Bing
    Maps Locations API! Let's now see how to use Python to automate this process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你刚刚使用Bing Maps Locations API将作为查询参数传递的地址进行了地理编码！现在让我们看看如何使用Python自动化这个过程。
- en: Geocoding addresses using Python
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python进行地址地理编码
- en: In this section, we'll show you how to make calls to the Bing Maps Locations
    API using both a direct call to the URL via the `GET` method (which is ultimately
    equivalent to the example call you made earlier via the browser) and a dedicated
    Python **Software Development Kit** (**SDK**) that facilitates the query.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你展示如何使用直接通过`GET`方法调用URL（这最终等同于你之前通过浏览器进行的示例调用）以及一个专门的Python **软件开发工具包**（**SDK**），它简化了查询过程。
- en: Using an explicit GET request
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用显式的GET请求
- en: 'If we want to receive geocoding data for an address from the Bing API, we need
    to make a request to the web service by passing the address of interest as a parameter.
    The parameters are passed through appropriate concatenation of the parameters
    with the URL of the endpoint. In our case, the full format of the endpoint URL
    useful for geocoding an address is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从Bing API接收地址的地理编码数据，我们需要通过传递感兴趣的地址作为参数来向Web服务发起请求。参数通过将参数与端点URL进行适当的连接传递。在我们的例子中，用于地理编码地址的端点URL的完整格式如下：
- en: '![Figure 9.3 – URL format of a GET request to the Bing Maps Locations API](img/file229.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 使用Bing Maps Locations API的GET请求的URL格式](img/file229.png)'
- en: Figure 9.3 – URL format of a GET request to the Bing Maps Locations API
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 使用Bing Maps Locations API的GET请求的URL格式
- en: 'The following is the definition of each string token you can see in *Figure
    9.3*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在图*9.3*中可以看到的每个字符串标记的定义：
- en: '`base_url`: The endpoint URL string, that is, `http://dev.virtualearth.net/REST/v1/Locations/`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base_url`：端点URL字符串，即`http://dev.virtualearth.net/REST/v1/Locations/`'
- en: '`address`: The string of the address that you want to geocode, transformed
    using the *percent encoding* technique to avoid using special characters in the
    final URL'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：你想要进行地理编码的地址字符串，使用*百分编码*技术转换，以避免在最终的URL中使用特殊字符'
- en: '`AUTH_KEY`: Your Bing key'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTH_KEY`：你的Bing密钥'
- en: 'Once the URL has been built in this way, it can be used to make a `GET` request
    via the `get()` method of the `requests` module. After getting the data as a result
    of the request, you’ll capture the content of the web service response containing
    JSON, and from that, you can extract the values of interest. For example, in order
    to extract the `formattedAddress` value, you have to navigate into the data structure,
    as shown in *Figure 9.4*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建了URL后，可以使用`requests`模块的`get()`方法来发起一个`GET`请求。在请求成功后，你会捕获包含JSON的Web服务响应内容，并从中提取感兴趣的值。例如，为了提取`formattedAddress`值，你需要导航到数据结构中，如图*9.4*所示：
- en: '![Figure 9.4 – Visual structure of the Bing Maps Locations API response](img/file230.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – Bing Maps Locations API响应的视觉结构](img/file230.png)'
- en: Figure 9.4 – Visual structure of the Bing Maps Locations API response
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – Bing Maps Locations API 响应的视觉结构
- en: 'So, you can navigate your JSON variable `data`, in the same way to get that
    value, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以像这样导航你的 JSON 变量 `data`，以获取该值：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From *Figure 9.4*, you can see that the resources node can contain more than
    one subnode, identified with an integer. This is because sometimes the geocoding
    engine cannot exactly identify the geographic point from the passed address and
    therefore returns more than one result. The `estimatedTotal` attribute indicates
    the number of possible geocodes identified. For simplicity, we have extracted
    from the JSON the last identified resource, which is the one with the highest
    identifier.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 9.4* 中，你可以看到资源节点可以包含多个子节点，这些子节点用整数标识。这是因为有时地理编码引擎无法精确地从传递的地址中识别地理点，因此返回多个结果。`estimatedTotal`
    属性指示已识别的可能地理编码的数量。为了简单起见，我们从 JSON 中提取了最后识别的资源，即具有最高标识符的资源。
- en: 'Besides the answer in JSON format, from the request, you can also extract other
    values, such as the reason for the state of the answer (useful to understand whether
    the `GET` operation is successful or not), the complete content of the answer
    in text format, and the URL used for the `GET` request. You will need the `requests`,
    `urllib`, `json`, `pandas`, and `time` modules. The latter is used to measure
    the geocoding execution time of all addresses in the dataset. Everything can be
    encapsulated in a handy function called `bing_geocode_via_address()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JSON 格式的答案外，你还可以从请求中提取其他值，例如答案状态的理由（有助于了解 `GET` 操作是否成功），文本格式的答案的完整内容，以及用于
    `GET` 请求的 URL。你需要 `requests`、`urllib`、`json`、`pandas` 和 `time` 模块。后者用于测量数据集中所有地址的地理编码执行时间。所有这些都可以封装在一个方便的函数中，称为
    `bing_geocode_via_address()`：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code chunks contained in this section are available in the `01-geocoding-with-python.py`
    file inside the `Chapter09\Python` folder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含的代码块可在 `Chapter09\Python` 文件夹中的 `01-geocoding-with-python.py` 文件中找到。
- en: 'Assuming we have a list of addresses to geocode in a pandas DataFrame, it makes
    sense to write a handy function that takes as input a DataFrame row and the column
    name in which the address is stored. It will invoke the previous function to get
    geocoding values to add to the current row and will return it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含要地理编码地址的 pandas DataFrame 的列表，编写一个方便的函数，该函数接受 DataFrame 行和存储地址的列名作为输入是有意义的。它将调用前面的函数以获取地理编码值以添加到当前行，并将返回它：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can test these functions using the test dataset at this link: [http://bit.ly/geocoding-test-addresses](http://bit.ly/geocoding-test-addresses).
    It’s also available in the `Chapter09` folder.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此链接中的测试数据集测试这些函数：[http://bit.ly/geocoding-test-addresses](http://bit.ly/geocoding-test-addresses)。它也位于
    `Chapter09` 文件夹中。
- en: 'You have to simply pass the previous function as a parameter to the addresses''
    DataFrame `apply()` method to apply it to each of its rows, shown as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将前面的函数作为参数传递给地址的 DataFrame `apply()` 方法，以将其应用于其每一行，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that the Bing Maps services key is set using the `os.environ.get(''BINGMAPS_API_KEY'')`
    function call. This way of accessing sensitive data avoids having to write it
    in plain text in the code. So, it must have been previously written to the `BINGMAPS_API_KEY`
    environment variable. You can also do this with Python via the following script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Bing Maps 服务密钥是通过 `os.environ.get('BINGMAPS_API_KEY')` 函数调用来设置的。这种方式访问敏感数据避免了在代码中以纯文本形式写入它。因此，它必须已经预先写入到
    `BINGMAPS_API_KEY` 环境变量中。你也可以通过以下脚本使用 Python 来完成此操作：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This way, however, each time you restart Visual Studio Code, that variable
    will be lost. To have it permanently available, you must set up a user variable
    environment directly through your operating system. In Windows, you can follow
    this guide: [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable).
    Once added, you must restart Visual Studio Code to make it visible to your code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次你重新启动 Visual Studio Code 时，该变量都会丢失。为了使其永久可用，你必须通过你的操作系统直接设置用户变量环境。在 Windows
    上，你可以按照以下指南操作：[https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable)。一旦添加，你必须重新启动
    Visual Studio Code 以使其对代码可见。
- en: '**Important Note**'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We preferred to load the CSV file directly into the Python script. It would
    have been equivalent to first loading the CSV file via the Power BI **Text/CSV**
    connector and then adding a transformation step that would run the Python code
    we just analyzed.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们更倾向于直接将 CSV 文件加载到 Python 脚本中。这相当于首先通过 Power BI **文本/CSV** 连接器加载 CSV 文件，然后添加一个转换步骤，该步骤将运行我们刚刚分析的
    Python 代码。
- en: 'The geocoding operation takes about 34 seconds for 120 addresses. Part of the
    content of the final DataFrame is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码操作对于 120 个地址大约需要 34 秒。最终 DataFrame 的一部分内容如下：
- en: '![Figure 9.5 – Content of the geocoded DataFrame](img/file231.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 地理编码 DataFrame 的内容](img/file231.png)'
- en: Figure 9.5 – Content of the geocoded DataFrame
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 地理编码 DataFrame 的内容
- en: Impressive! You geocoded as many as 120 addresses with just a few lines of Python
    code in 34 seconds. But did you know that you can also parallelize `GET` requests
    by geocoding all your addresses in less time? Let's see how you can achieve this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 壮观！您仅用几行 Python 代码在 34 秒内地理编码了多达 120 个地址。但您知道您还可以通过地理编码所有地址来并行化 `GET` 请求，从而在更短的时间内完成吗？让我们看看您如何实现这一点。
- en: Using an explicit GET request in parallel
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用并行显式 GET 请求
- en: Just as you learned in *Chapter 8*, *Loading Large Datasets beyond the Available
    RAM in Power BI*, the Swiss army knife that allows you to parallelize your computations
    in Python is Dask. The great thing is that a Dask DataFrame exposes the `apply()`
    method, which has the same functionality as a pandas DataFrame’s `apply()`function,
    with the difference that it is parallelized. Therefore, the code used in the previous
    section is practically reusable with a few minor modifications to achieve significantly
    reduced execution times. You can find the full script in the `02-geocoding-parallel-with-python.py`
    file in the `Chapter09\Python` folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 *第 8 章* 中学到的，*在 Power BI 中加载超过可用 RAM 的大型数据集*，瑞士军刀允许您在 Python 中并行化您的计算是
    Dask。好事是 Dask DataFrame 提供了 `apply()` 方法，它具有与 pandas DataFrame 的 `apply()` 函数相同的功能，不同之处在于它是并行的。因此，上一节中使用的代码经过一些小的修改就可以实现显著减少执行时间。您可以在
    `Chapter09\Python` 文件夹中的 `02-geocoding-parallel-with-python.py` 文件中找到完整的脚本。
- en: '**Important Note**'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When the API requires it, it is preferable to provide multiple inputs using
    **batch mode**, rather than making multiple calls in parallel. However, if batch
    mode is not covered by the API, multiple parallel calls are the only way to improve
    execution times. The Bing Maps Locations API supports batch mode, but for demonstration
    purposes, we preferred to adopt the multiple call technique.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 API 需要时，最好使用 **批量模式** 提供多个输入，而不是并行进行多次调用。然而，如果批量模式不受 API 支持，那么多次并行调用是提高执行时间的唯一方法。Bing
    Maps Locations API 支持批量模式，但为了演示目的，我们更喜欢采用多次调用技术。
- en: 'The `enrich_with_geocoding()` and `bing_geocode_via_address()` functions remain
    as they are. Instead, the Dask DataFrame is introduced already at the data reading
    stage, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`enrich_with_geocoding()` 和 `bing_geocode_via_address()` 函数保持不变。相反，Dask DataFrame
    已经在数据读取阶段引入，如下所示：'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Internally, a Dask DataFrame is divided into many partitions, where each partition
    is a pandas DataFrame. Now, it happens that when the data is not a large amount,
    it may be loaded in a single partition by `read_csv()`. In fact, if you run the
    following code: `ddf.npartitions`, you will see that it returns `1`. It is for
    this reason that in cases such as this, it is necessary to repartition the Dask
    DataFrame into an appropriate number of partitions to benefit from parallelism,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Dask DataFrame 被划分为许多分区，其中每个分区都是一个 pandas DataFrame。现在，当数据量不大时，它可能通过 `read_csv()`
    在单个分区中加载。实际上，如果您运行以下代码：`ddf.npartitions`，您将看到它返回 `1`。正因为如此，在这种情况下，有必要将 Dask DataFrame
    重新分区到适当的分区数量，以利用并行性，如下所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following applies to the number of partitions in a DataFrame:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下适用于 DataFrame 中的分区数量：
- en: '**Important Note**'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is no precise rule for determining the ideal number of partitions in a
    DataFrame. The formula used earlier is effective for the dataset we are considering
    here and has been determined empirically.
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 DataFrame 中确定理想分区数量的精确规则并不存在。之前使用的公式对我们正在考虑的数据集是有效的，并且是通过经验确定的。
- en: 'At this point, you have to simply invoke the `apply()` method of the Dask DataFrame
    by passing it the `enrich_with_geocoding()` function, as you did with the `apply()`
    method of the pandas DataFrame in the previous section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你只需通过传递`enrich_with_geocoding()`函数来调用Dask DataFrame的`apply()`方法，就像你在上一节中使用pandas
    DataFrame的`apply()`方法时做的那样：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we had to specify the expected metadata of the output. This is
    because many operations on DataFrames rely on knowing the name and type of the
    column. Internally, Dask DataFrame does its best to propagate this information
    through all operations. Usually, this is done by evaluating the operation on a
    small sample of dummy data. Sometimes, however, this operation can fail in user-defined
    functions (such as in the case of `apply`). In these cases, many functions support
    an optional `meta` keyword, which allows you to specify the metadata directly,
    avoiding the inference step.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须指定预期的输出元数据。这是因为许多DataFrame上的操作依赖于知道列的名称和类型。内部，Dask DataFrame尽其所能通过所有操作传播此信息。通常，这是通过在小型虚拟数据集上评估操作来完成的。有时，然而，这种操作可能会在用户定义的函数（如`apply`）中失败。在这些情况下，许多函数支持一个可选的`meta`关键字，它允许你直接指定元数据，从而避免推断步骤。
- en: '**Important Note**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dask DataFrame’s `apply()` method now supports only the `axis=1` mode (row-wise).
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dask DataFrame的`apply()`方法现在只支持`axis=1`模式（按行）。
- en: 'You’ve just defined a lazy transformation. To actually perform it, you must
    use the `compute()` function, so in this case, you can measure the time it takes
    to geocode all the addresses:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚定义了一个懒转换。要实际执行它，你必须使用`compute()`函数，因此在这种情况下，你可以测量地理编码所有地址所需的时间：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The end result is stunning: 120 addresses were geocoded in *just 3.5 seconds*
    versus 35 seconds for sequential code! You have achieved a 10x improvement in
    running time thanks to Dask!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是惊人的：120个地址在仅仅*3.5秒*内就被地理编码了，而顺序代码需要35秒！多亏了Dask，你实现了运行时间的10倍提升！
- en: As you've seen in this section and the previous one, the most uncomfortable
    part of the code is perhaps retrieving every single value from the JSON returned
    by the web service (the logic in the `bing_geocode_via_address()` function), because
    you have to know in advance the structure of the result obtained. However, there
    are Python modules that contain functions that facilitate interaction with specific
    web services. Let's see how to use the `Geocoder` library, which simplifies the
    adoption of the most widely used geocoding providers, such as those of Google
    and Bing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节和上一节中看到的，代码中最不舒服的部分可能是从网络服务返回的JSON中检索每个值（`bing_geocode_via_address()`函数中的逻辑），因为你必须事先知道结果的架构。然而，有一些Python模块包含用于与特定网络服务交互的函数。让我们看看如何使用`Geocoder`库，它简化了最广泛使用的地理编码提供商（如Google和Bing）的采用。
- en: Using the Geocoder library in parallel
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行使用Geocoder库
- en: The **Geocoder** module ([https://geocoder.readthedocs.io/](https://geocoder.readthedocs.io/))
    is a simple and consistent geocoding library written in Python. It makes consistent
    responses from expected geocoding providers using a unique JSON schema. Some of
    the providers available are Google, Bing, Mapbox, and TomTom.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geocoder**模块([https://geocoder.readthedocs.io/](https://geocoder.readthedocs.io/))是一个用Python编写的简单且一致的地理编码库。它使用独特的JSON模式从预期的地理编码提供商那里获得一致的响应。一些可用的提供商包括Google、Bing、Mapbox和TomTom。'
- en: 'First, you need to install the Geocoder library in the `pbi_powerquery_env`
    environment. You can do that by following these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在`pbi_powerquery_env`环境中安装Geocoder库。你可以通过以下步骤完成：
- en: Open the Anaconda prompt.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Anaconda提示符。
- en: 'Switch to the `pbi_powerquery_env` environment by entering this command: `conda
    activate pbi_powerquery_env`.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令切换到`pbi_powerquery_env`环境：`conda activate pbi_powerquery_env`。
- en: 'Install the Geocoder library by entering this command: `pip install geocoder`.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令安装Geocoder库：`pip install geocoder`。
- en: 'Thanks to Geocoder, the `GET` request for an address is simply transformed
    into the command `r = geocoder.bing(address, key = AUTH_KEY)`. And the great thing
    is that the returned object, `r`, already contains the attributes useful for geocoding,
    such as `r.address`, `r.lat`, or `r.lng`. Therefore, the `bing_geocode_via_address()`
    function you encountered in the previous sections is embarrassingly simplified,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Geocoder，对地址的`GET`请求被简单地转换成了命令`r = geocoder.bing(address, key = AUTH_KEY)`。而且，返回的对象`r`已经包含了用于地理编码的有用属性，例如`r.address`、`r.lat`或`r.lng`。因此，你在上一节中遇到的`bing_geocode_via_address()`函数被尴尬地简化了，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, Geocoder selects the most appropriate match if the geocoding operation
    returns more than one match, saving you from further headaches. The option to
    return multiple results is currently an in-progress development. In more recent
    versions of the package, it is possible to pass the `MaxRows` parameter with a
    value greater than one to the geocoding functions to obtain as many possible results
    as the value passed. In this way, it is the analyst who can choose the outcome
    that meets their needs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果地理编码操作返回多个匹配项，Geocoder 会选择最合适的匹配项，从而节省你进一步的麻烦。返回多个结果的功能目前还在开发中。在包的较新版本中，你可以通过将大于一值的
    `MaxRows` 参数传递给地理编码函数，以获取尽可能多的可能结果。这样，分析师就可以选择满足他们需求的结果。
- en: You can find the complete script that uses the Geocoder library to geocode addresses
    in parallel in the `03-geocoding-parallel-using-sdk-with-python.py` file in the
    `Chapter09\Python` folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Chapter09\Python` 文件夹中的 `03-geocoding-parallel-using-sdk-with-python.py`
    文件中找到使用 Geocoder 库并行地理编码地址的完整脚本。
- en: You can now understand that having an SDK available that is designed to simplify
    your life in using a specific API is a major boon.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以理解拥有一个旨在简化你使用特定 API 生活的 SDK 是一件大好事。
- en: '**Important Note**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the overarching principles we always suggest is to *avoid reinventing
    the wheel* every time you need it. If you need to accomplish a goal (in our case,
    geocoding an address), most likely someone before you has already thought of it
    and perhaps shared a library with the community that simplifies your life. Always
    spend a half-hour searching the web for possible pre-existing solutions that can
    smartly solve your problem. In addition to saving valuable time, you avoid the
    risk of going crazy with complexities that others have already overcome for you.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们始终建议的一个主要原则是，每次你需要它时都 *避免重新发明轮子*。如果你需要完成一个目标（在我们的案例中，地理编码一个地址），很可能在你之前有人已经想到了它，并且可能已经与社区分享了一个简化你生活的库。始终花半小时在网络上搜索可能的现有解决方案，这些解决方案可以智能地解决你的问题。除了节省宝贵的时间外，你还避免了陷入别人已经克服的复杂性的风险。
- en: Although we knew of the existence of the Geocoder library, we still wanted to
    show you how to make `GET` requests to the web service from scratch in the previous
    sections. This is because it is not certain that SDKs exist for all web services
    that you may need in the future.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已知 Geocoder 库的存在，但我们仍然想在前面几节中向你展示如何从头开始向网络服务发送 `GET` 请求。这是因为并不能确定所有你未来可能需要的网络服务都有
    SDK。
- en: Let's now see how to get the same results using R.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 R 获取相同的结果。
- en: Geocoding addresses using R
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 R 进行地址地理编码
- en: You have just learned how to query a web service via raw `GET` requests to the
    endpoint and via a handy SDK using Python. As you can already guess, you can also
    do both with R. Let's see how it’s done.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何通过原始 `GET` 请求到端点以及通过方便的 SDK 使用 Python 查询网络服务。正如你所能猜到的，你也可以使用 R 来做这两件事。让我们看看如何操作。
- en: Using an explicit GET request
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用显式的 `GET` 请求
- en: 'The package that allows calls to URLs in R is `httr` (installed by default
    with the engine). Making a `GET` request simply translates to `GET(your_url)`
    thanks to it. As you have already seen in the previous sections, **percent encoding**
    must be applied to the address to be passed as a web parameter to the Bing Maps
    Locations API endpoint. The function that allows you to apply this type of encoding
    to a string is found in the `RCurl` package and is named `curlPercentEncode()`.
    In addition, the handy `tictoc` package will be used to measure run times. Both
    the `RCurl` and `tictoc` packages need to be installed, as shown in the following
    steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在 R 中调用 URL 的包是 `httr`（默认与引擎一起安装）。通过它，简单的 `GET` 请求直接转换为 `GET(your_url)`。正如你在前面的章节中已经看到的，**百分编码**必须应用于要作为网络参数传递给
    Bing Maps Locations API 端点的地址。允许你对字符串应用此类编码的函数在 `RCurl` 包中，命名为 `curlPercentEncode()`。此外，方便的
    `tictoc` 包将被用来测量运行时间。`RCurl` 和 `tictoc` 包都需要安装，如下面的步骤所示：
- en: Open RStudio and make sure it is referencing your latest CRAN R engine in **Global
    Options**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 RStudio 并确保它在 **全局选项** 中引用你最新的 CRAN R 引擎。
- en: 'Click on the **Console** window and enter this command: `install.packages("RCurl")`.
    Then press *Enter* key.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **控制台** 窗口，并输入以下命令：`install.packages("RCurl")`。然后按 *Enter* 键。
- en: 'Enter this command: `install.packages("tictoc")`. Then press **Enter**.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：`install.packages("tictoc")`。然后按 **Enter**。
- en: 'At this point, once you have defined the `base_url` and `AUTH_KEY` variables
    specific to the web service to query, it is enough to execute the following code
    to obtain the result of a `GET` request:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一旦你定义了针对查询的特定于 Web 服务的 `base_url` 和 `AUTH_KEY` 变量，执行以下代码就足以获得 `GET` 请求的结果：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `str_glue()` function of the `stringr` package has been used to concatenate
    the strings. Note that also, in this case, the `AUTH_KEY` variable is set from
    an environment variable using `AUTH_KEY = Sys.getenv(''BINGMAPS_API_KEY'')`. This
    means that the environment variable must be set beforehand. You can set it directly
    in your R session using the following R script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringr` 包的 `str_glue()` 函数已被用于连接字符串。请注意，在这种情况下，`AUTH_KEY` 变量也是通过使用 `AUTH_KEY
    = Sys.getenv(''BINGMAPS_API_KEY'')` 从环境变量设置的。这意味着必须在之前设置环境变量。你可以在 R 会话中使用以下 R
    脚本直接设置它：'
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This way, however, each time you restart RStudio, that variable will be lost.
    To have it permanently available, you must set up a user variable environment
    directly through your operating system. In Windows, you can follow this guide:
    [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable).
    Once added, you must restart RStudio to make it visible to your code.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次你重新启动 RStudio 时，该变量都会丢失。为了使其永久可用，你必须通过你的操作系统直接设置用户变量环境。在 Windows 中，你可以遵循以下指南：[https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable)。一旦添加，你必须重新启动
    RStudio 以使其对代码可见。
- en: Once you have obtained the result of the request, you can proceed to parse the
    JSON content to obtain the desired geocoding values. Everything that was taken
    into account for parsing the result in the previous sections still applies. So
    again, you will have to handle the multiple results that some geocoding operations
    might return. As already done for the Python scripts used previously, all this
    logic can be encapsulated into the `bing_geocode_via_address()` function in R
    that returns a list of values obtained as a result of geocoding a passed address.
    You can find the code in the `01-geocoding-with-r.R` file in the `R\Chapter09`
    folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了请求的结果，你就可以继续解析 JSON 内容以获取所需的地理编码值。在前面章节中解析结果时所考虑的一切仍然适用。因此，你将不得不处理一些地理编码操作可能返回的多个结果。正如之前用于
    Python 脚本所做的那样，所有这些逻辑都可以封装到 R 中的 `bing_geocode_via_address()` 函数中，该函数返回通过地理编码传递的地址所获得的一系列值。你可以在
    `R\Chapter09` 文件夹中的 `01-geocoding-with-r.R` 文件中找到代码。
- en: 'Once you have loaded the contents of the `geocoding_test_data.csv` file into
    the `tbl_orig` tibble and selected the columns of interest in `tbl`, you will
    exploit the convenience of the `purrr` package''s `map()` function to execute
    the previous defined `bing_geocode_via_address()` function for each address extracted
    from the tibble:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `geocoding_test_data.csv` 文件的内容加载到 `tbl_orig` tibble 中，并在 `tbl` 中选择了感兴趣的列，你将利用
    `purrr` 包的 `map()` 函数的便利性来为从 tibble 中提取的每个地址执行之前定义的 `bing_geocode_via_address()`
    函数：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how we used the `pull()` function to transform the `full_address` tibble
    column into a vector and then passed it as a parameter to the `map_dfr()` function,
    which only accepts lists or vectors as input. You may be wondering what the `map_dfr()`
    function is for. It is part of the `purrr` family of `map()` functions. While
    `map()` returns a list of results (each obtained by applying the input function
    to each element of the input vector) as output, `map_dfr()` directly binds rows
    when each element of the `map()` output is a named DataFrame, list, or vector.
    So the final result of `map_dfr()` is a DataFrame/tibble composed of the elements
    returned by the input function arranged row by row. The whole logic is wrapped
    by the pair of functions, `tic()` and `toc()`. By running the entire block of
    code (from `tic()` to `toc()` inclusive), you can get the execution time of the
    code inside very conveniently.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `pull()` 函数将 `full_address` tibble 列转换为向量，然后将它作为参数传递给 `map_dfr()` 函数，该函数只接受列表或向量作为输入。你可能想知道
    `map_dfr()` 函数是做什么用的。它是 `map()` 函数家族的一部分。虽然 `map()` 返回一个结果列表（每个结果都是通过将输入函数应用于输入向量的每个元素获得的）作为输出，但
    `map_dfr()` 直接将行绑定，当 `map()` 的每个输出元素都是一个命名 DataFrame、列表或向量时。因此，`map_dfr()` 的最终结果是一个由输入函数返回的元素按行排列的
    DataFrame/tibble。整个逻辑被 `tic()` 和 `toc()` 函数对封装起来。通过运行整个代码块（从 `tic()` 到 `toc()`
    包括），你可以非常方便地获得代码内部的执行时间。
- en: You may have noticed that there is no need in this case for an intermediate
    function such as `enrich_with_geocoding()` that accepts the individual lines of
    the tibble as a parameter. Since the `bing_geocode_via_address()` function returns
    a named list, the `map_dfr()` function manages to interpret it correctly and bind
    it into a single tibble.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这种情况下不需要像`enrich_with_geocoding()`这样的中间函数，该函数接受tibble的单独行作为参数。由于`bing_geocode_via_address()`函数返回一个命名列表，`map_dfr()`函数能够正确地解释它并将其绑定到一个单一的tibble中。
- en: '**Important Note**'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We preferred to load the CSV file directly into the R script. It would have
    been equivalent to first loading the CSV file via the Power BI **Text/CSV** connector
    and then adding a transformation step that would run the R code we just analyzed.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们更喜欢直接将CSV文件加载到R脚本中。这相当于首先通过Power BI的**文本/CSV**连接器加载CSV文件，然后添加一个运行我们刚刚分析的R代码的转换步骤。
- en: 'Since `map_dfr()` only returns a tibble of geocoding values, you have to bind
    this tibble to the initial `tbl` one in order to have a single enriched tibble.
    For this reason, we used the function `bind_cols(tbl, .)`, where the parameter
    `.` denotes the tibble of geocoding values passed as a parameter by the piping
    operation. That said, the whole geocoding operation takes about 30 seconds (which
    is comparable to the result obtained with Python), and the final tibble will look
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`map_dfr()`只返回一个地理编码值的tibble，你必须将这个tibble绑定到初始的`tbl`上，以便得到一个单一的增强型tibble。因此，我们使用了函数`bind_cols(tbl,
    .)`，其中参数`.`表示通过管道操作传递的地理编码值tibble。话虽如此，整个地理编码操作大约需要30秒（这与使用Python得到的结果相当），最终的tibble将如下所示：
- en: '![Figure 9.6 – Content of the geocoded DataFrame](img/file232.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 地理编码DataFrame的内容](img/file232.png)'
- en: Figure 9.6 – Content of the geocoded DataFrame
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 地理编码DataFrame的内容
- en: Well done! You were able to geocode addresses via the web service even with
    R. Easy, right? Are you now curious to learn how to do this by taking advantage
    of the parallelism provided by your machine? Let's see how to proceed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你甚至使用R也能通过网络服务进行地址地理编码。简单，对吧？你现在是否好奇想了解如何利用机器提供的并行性来完成这项工作？让我们看看如何进行。
- en: Using an explicit GET request in parallel
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用并行显式GET请求
- en: Just as in Python, we had to use the Dask module to parallelize computations;
    in R, we need to introduce a new package to achieve the same thing. The new package
    is called `furrr` ([https://furrr.futureverse.org/](https://furrr.futureverse.org/))
    and is intended to combine the expressive power of the `purrr` family of mapping
    functions with the parallel processing capabilities provided by the **future**
    package ([https://future.futureverse.org/](https://future.futureverse.org/)).
    Both the `furrr` and `future` packages are part of an interesting framework called
    **Futureverse** ([https://www.futureverse.org/](https://www.futureverse.org/)),
    which aims to parallelize existing R code in the simplest way. In practical terms,
    `furrr` allows you to replace the `map()` and `map_*()` functions of `purrr` with
    the `future_map()` and `future_map_*()` functions of `furrr` with minimal effort,
    and your code will magically run in parallel. Keep in mind that the future engine
    is also the backend used by the `disk.frame` packages you learned about in *Chapter
    8*, *Loading Large Datasets beyond the Available RAM in Power BI*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Python中一样，我们不得不使用Dask模块来并行化计算；在R中，我们需要引入一个新的包来实现相同的功能。这个新包叫做`furrr`([https://furrr.futureverse.org/](https://furrr.futureverse.org/))，旨在将`purrr`家族映射函数的表达能力与`future`包提供的并行处理能力结合起来([https://future.futureverse.org/](https://future.futureverse.org/))。`furrr`和`future`包都是称为**Futureverse**([https://www.futureverse.org/](https://www.futureverse.org/))的有趣框架的一部分，该框架旨在以最简单的方式并行化现有的R代码。在实践中，`furrr`允许你用最小的努力将`purrr`的`map()`和`map_*()`函数替换为`furrr`的`future_map()`和`future_map_*()`函数，你的代码将神奇地并行运行。请注意，未来引擎也是你在第8章“在Power
    BI中加载超过可用RAM的大型数据集”中了解到的`disk.frame`包的后端。
- en: First of all, you need to install the `furrr` package. Just run the command
    `install.packages("furrr")` in the RStudio’s **Console** window and that’s it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装`furrr`包。只需在RStudio的**控制台**窗口中运行命令`install.packages("furrr")`即可。
- en: 'To apply what has just been said to the code analyzed in the previous section,
    it is enough to modify the last part of it as follows to obtain the same result
    (and obviously loading the `furrr` library instead of `purrr`), but while parallelizing
    the computations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将刚刚所说的应用到前一个章节中分析的代码，只需修改其最后一部分如下即可获得相同的结果（并且显然加载`furrr`库而不是`purrr`），但在并行化计算的同时：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Thanks to the `availableCores()` function, it is possible to identify the number
    of virtual processors present on the machine. It is good practice not to use all
    of them as it can make the machine unresponsive. The `plan()` function of a future
    instance allows you to define the strategy with which the future engine performs
    the calculations (synchronously or asynchronously). It also allows you to define
    the number of workers that will work in parallel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`availableCores()`函数，您可以识别出机器上存在的虚拟处理器的数量。不使用所有这些是一个好的做法，因为它可以使机器变得无响应。未来实例的`plan()`函数允许您定义未来引擎执行计算的策略（同步或异步）。它还允许您定义将并行工作的工人数。
- en: '**Important Note**'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generally, the default strategy used on Windows machines is **multisession**
    and it works fine running the code in RStudio. We found that with this strategy,
    Power BI cannot handle the multiple sessions generated to parallelize computations.
    Instead, we found that selecting the **cluster** strategy, despite the machine
    being unique, allows Power BI to complete the computations.
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，Windows机器上使用的默认策略是**多会话**，并且它在RStudio中运行代码时表现良好。我们发现，使用这种策略，Power BI无法处理为并行计算生成的多个会话。相反，我们发现选择**集群**策略，尽管机器是唯一的，但允许Power
    BI完成计算。
- en: 'Another minimal change was to declare the `base_url` and `AUTH` variables associated
    with the web service directly in the function invoked by `future_map_dfr()` instead
    of in the main code for simplicity. Passing variables to functions invoked via
    `furrr` is done slightly differently than in standard practice (follow this link:
    [https://furrr.futureverse.org/articles/articles/gotchas.html](https://furrr.futureverse.org/articles/articles/gotchas.html)),
    and we wanted to avoid adding minimal complexity so as not to distract from the
    main concept.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最小的改动是将与网络服务相关的`base_url`和`AUTH`变量直接声明在由`future_map_dfr()`调用的函数中，而不是在主代码中，以简化操作。通过`furrr`调用函数传递变量与标准实践略有不同（请参阅此链接：[https://furrr.futureverse.org/articles/articles/gotchas.html](https://furrr.futureverse.org/articles/articles/gotchas.html))，我们希望避免增加最小复杂性，以免分散对主要概念的注意力。
- en: You can find the full script in the `02-geocoding-parallel-with-r.R` file in
    the `Chapter09\R` folder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter09\R`文件夹中的`02-geocoding-parallel-with-r.R`文件中找到完整的脚本。
- en: 'If you run the code, you will get impressive results: 120 addresses were geocoded
    in *just 3 seconds* versus 30 seconds for sequential code! Also, in this case,
    you achieved a 10x improvement in running time thanks to `furrr`! Simple as that,
    right?'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行代码，您将得到令人印象深刻的结果：120个地址在仅仅*3秒*内就被地理编码了，而顺序代码需要30秒！此外，在这种情况下，您通过`furrr`实现了运行时间的10倍提升！就这么简单，对吧？
- en: You can further simplify the code you just ran by adopting a geocoding package
    that does the bulk of the work for you in invoking the web service. Let's see
    what this is all about.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过采用一个为您调用网络服务的大部分工作的地理编码包来进一步简化您刚刚运行的代码。让我们看看这是怎么回事。
- en: Using the tidygeocoder package in parallel
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用tidygeocoder包并行处理
- en: The `tidygeocoder` ([https://jessecambon.github.io/tidygeocoder/](https://jessecambon.github.io/tidygeocoder/))
    package provides a unified high-level interface for a selection of supported geocoder
    services and returns results in tibble format. Some of the providers available
    are Google, Mapbox, TomTom, and Bing (starting with version 1.0.3).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`tidygeocoder` ([https://jessecambon.github.io/tidygeocoder/](https://jessecambon.github.io/tidygeocoder/))
    包提供了一组受支持的地理编码服务的统一高级接口，并以tibble格式返回结果。一些可用的提供者包括Google、Mapbox、TomTom和Bing（从版本1.0.3开始）。'
- en: 'First of all, you need to install it. If you want to install the latest version,
    remember to reset the snapshot repository using the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装它。如果您想安装最新版本，请记住使用以下代码重置快照存储库：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, you can simply run the `install.packages("tidygeocoder")` command in the
    Console window.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需在控制台窗口中运行`install.packages("tidygeocoder")`命令即可。
- en: 'Thanks to Tidygeocoder, the `GET` request for an address is simply transformed
    into the `details_tbl <- geo(address, method = ''bing'', full_results = TRUE)`
    command, and the great thing is that the returned object, `r`, already contains
    the attributes useful for geocoding, such as `details_tbl$bing_address.formattedAddress`.
    Therefore, the `bing_geocode_via_address()` function you encountered in the previous
    sections is embarrassingly simplified, as shown in the following code block:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Tidygeocoder，对地址的 `GET` 请求被简单地转换为 `details_tbl <- geo(address, method =
    'bing', full_results = TRUE)` 命令，而且令人高兴的是，返回的对象 `r` 已经包含了用于地理编码的有用属性，例如 `details_tbl$bing_address.formattedAddress`。因此，您在前几节中遇到的
    `bing_geocode_via_address()` 函数显得过于简单，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Also, in this case, the tidygeocoder package selects the most appropriate match
    if the geocoding operation returns more than one, saving you from further headaches.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，tidygeocoder 包会在地理编码操作返回多个匹配项时选择最合适的匹配项，从而让您免受更多头痛的困扰。
- en: '**Important Note**'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that Tidygeocoder assumes that the `BINGMAPS_API_KEY` environment variable
    has been set and uses it to log in to the web service.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，Tidygeocoder 假设已经设置了 `BINGMAPS_API_KEY` 环境变量，并使用它来登录到网络服务。
- en: You can find the complete script that uses the Geocoder library to geocode addresses
    in parallel in the `03-geocoding-parallel-using-sdk-with-r.R` file in the `Chapter09\R`
    folder.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter09\R` 文件夹中的 `03-geocoding-parallel-using-sdk-with-r.R` 文件中找到使用
    Geocoder 库并行地理编码地址的完整脚本。
- en: As you've probably figured out by now, using SDKs available to the community
    makes your life easier and is a winning choice. If an SDK for a specific web service
    is not available, you still learned how to make a raw `GET` request with R.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经猜到的，使用社区提供的 SDK 可以使您的生活更加轻松，是一个明智的选择。如果某个网络服务的 SDK 不可用，您仍然学习了如何使用 R
    进行原始 `GET` 请求。
- en: Let's now look at the benefits of what we've learned so far by implementing
    web service data enrichment solutions with R and Python in Power BI.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在 Power BI 中使用 R 和 Python 实现网络服务数据丰富解决方案来查看我们迄今为止所学内容的益处。
- en: Accessing web services using Power BI
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Power BI 访问网络服务
- en: 'Power BI already has default features that allow you to access the data exposed
    by a web service into Power Query. There are two main modes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Power BI 已经具有允许您将网络服务公开的数据访问到 Power Query 的默认功能。有两种主要模式：
- en: Via GUI (click on **Get data**, then **Web**, and then you can set advanced
    options if needed)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 GUI（点击 **获取数据**，然后 **网络**，如果需要，可以设置高级选项）
- en: Through the M language, using the `Web.Contents()` function
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 M 语言，使用 `Web.Contents()` 函数
- en: The use of the GUI is very cumbersome and almost always it does not lead to
    the desired results. The only way to effectively connect to a web service using
    native Power BI features is to write M code. Writing code in M is not too difficult.
    However, there are some complications in using the `Web.Contents()` function that
    arise when publishing a report that makes use of it to the Power BI service. In
    short, it is necessary to be careful when you have to build the URL to use in
    the `GET` request in a dynamic way, making use of the **relative path** and the
    **query options**. If you do not use this particular construct, the service will
    not be able to refresh the data. Moreover, the Power BI service does not allow
    you to securely store sensitive data, such as the API key, forcing you to embed
    this information into your code. In addition to that, multiple calls to an endpoint
    cannot be made in parallel using M.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GUI 非常繁琐，几乎总是无法达到预期的结果。要有效地使用 Power BI 的原生功能连接到网络服务，唯一的方法是编写 M 代码。在 M 中编写代码并不太难。然而，当将使用
    `Web.Contents()` 函数的报告发布到 Power BI 服务时，会出现一些复杂情况。简而言之，当您需要以动态方式构建用于 `GET` 请求的
    URL 时，必须小心使用 **相对路径** 和 **查询选项**。如果您不使用这种特定的结构，服务将无法刷新数据。此外，Power BI 服务不允许您安全地存储敏感数据，例如
    API 密钥，迫使您将此信息嵌入到代码中。此外，使用 M 无法并行地对端点进行多次调用。
- en: It is for the reasons listed above that we suggest using R or Python to access
    web services, especially if SDKs are available to facilitate their use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为上述原因，我们建议使用 R 或 Python 来访问网络服务，尤其是如果 SDK 可用以简化其使用。
- en: 'Keep in mind that the following restriction applies:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以下限制适用：
- en: '**Important Note**'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the report that uses web service data has to be published to the Power BI
    service, you can only query web services through Power Query and not within R
    visuals because the environment used by them on the service is not exposed on
    the internet.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果使用网络服务数据的报告需要发布到 Power BI 服务，您只能通过 Power Query 查询网络服务，而不能在 R 可视化中查询，因为它们在服务上使用的环境没有暴露在互联网上。
- en: 'That said, in order to be able to geolocate addresses using the Bing Maps Locations
    API in Power BI using the scripts we provide, the following clause applies:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，为了能够使用我们提供的脚本在 Power BI 中通过 Bing Maps Locations API 进行地址地理定位，以下条款适用：
- en: '**Important Note**'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You must define the `BINGMAPS_API_KEY` environment variable as a user environment
    variable on your operating system to use the geocoding script we’ll provide for
    Power BI. If the report that makes use of the data extracted from the web service
    will be published to the Power BI service, make sure to create the same environment
    variable on the data gateway machine as well.
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您必须在您的操作系统上定义 `BINGMAPS_API_KEY` 环境变量作为用户环境变量，才能使用我们为 Power BI 提供的地理编码脚本。如果使用从网络服务中提取的数据的报表需要发布到
    Power BI 服务，请确保在数据网关机器上也创建相同的环境变量。
- en: Now, let's see how to extract data from a web service in Power BI with Python.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Python 在 Power BI 中从网络服务中提取数据。
- en: Geocoding addresses in Power BI with Python
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 在 Power BI 中进行地址地理编码
- en: 'In Power BI, we will use the Python code that calls the web service through
    the Geocoder SDK and exploits the parallelism thanks to Dask. The code to be used
    is practically identical to that already analyzed previously. Therefore, it is
    enough to follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Power BI 中，我们将使用通过地理编码 SDK 调用网络服务的 Python 代码，并利用 Dask 实现并行处理。要使用的代码实际上与之前分析过的代码相同。因此，只需遵循以下步骤：
- en: Open Power BI Desktop and make sure it references the `pbi_powerquery_env` environment.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Power BI 桌面并确保它引用了 `pbi_powerquery_env` 环境。
- en: Click on **Get data**, search and select **Python script**, and then copy the
    script you can find in the `04-geocoding-parallel-using-sdk-in-power-bi-with-python.py`
    file into the `Chapter09\Python` folder. Make sure to edit the path to the `geocoding_test_data.csv`
    file. Then click **OK**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **获取数据**，搜索并选择 **Python 脚本**，然后将您在 `04-geocoding-parallel-using-sdk-in-power-bi-with-python.py`
    文件中找到的脚本复制到 `Chapter09\Python` 文件夹中。请确保编辑 `geocoding_test_data.csv` 文件的路径。然后点击
    **确定**。
- en: 'After a few seconds, you will see the **Navigator** window appear, where you
    can select the `enriched_df` table:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您将看到 **导航器** 窗口出现，您可以在其中选择 `enriched_df` 表：
- en: '![Figure 9.7 – The enriched_df DataFrame loaded in Power BI](img/file233.png)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 9.7 – 在 Power BI 中加载的 enriched_df 数据框](img/file233.png)'
- en: Figure 9.7 – The enriched_df DataFrame loaded in Power BI
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7 – 在 Power BI 中加载的 enriched_df 数据框
- en: Then, click on **Load**.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，点击 **加载**。
- en: You just queried the Bing Maps Locations API from within Power BI in parallel
    using Python! Easy, right?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚使用 Python 在 Power BI 中并行查询了 Bing Maps Locations API！简单，对吧？
- en: It is possible to do the same thing with R. Let's see how to proceed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以使用 R 来做同样的事情。让我们看看如何进行。
- en: Geocoding addresses in Power BI with R
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 在 Power BI 中进行地址地理编码
- en: 'In Power BI, we will use the R code that calls the web service through the
    Tidygeocoder SDK and that exploits the parallelism thanks to the `furrr` package.
    The code to be used is practically identical to that already analyzed previously.
    Therefore, it is enough to follow these steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Power BI 中，我们将使用通过 Tidygeocoder SDK 调用网络服务的 R 代码，并利用 `furrr` 包实现并行处理。要使用的代码实际上与之前分析过的代码相同。因此，只需遵循以下步骤：
- en: Open Power BI Desktop and make sure it references your latest CRAN R.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Power BI 桌面并确保它引用了您最新的 CRAN R。
- en: Click on **Get data**, search and select **Python script**, and then copy the
    script you can find in the `04-geocoding-parallel-using-sdk-in-power-bi-with-r.R`
    file into the `Chapter09\R` folder. Make sure to edit the path to the `geocoding_test_data.csv`
    file. Then click **OK**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **获取数据**，搜索并选择 **Python 脚本**，然后将您在 `04-geocoding-parallel-using-sdk-in-power-bi-with-r.R`
    文件中找到的脚本复制到 `Chapter09\R` 文件夹中。请确保编辑 `geocoding_test_data.csv` 文件的路径。然后点击 **确定**。
- en: 'After a few seconds, you will see the **Navigator** window appear, where you
    can select the `tbl_enriched` table:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您将看到 **导航器** 窗口出现，您可以在其中选择 `tbl_enriched` 表：
- en: '![Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI](img/file234.png)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 9.8 – 在 Power BI 中加载的 tbl_enriched 数据框](img/file234.png)'
- en: Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.8 – 在 Power BI 中加载的 tbl_enriched 数据框
- en: Then, click on **Load**.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，点击 **加载**。
- en: You just queried the Bing Maps Locations API from within Power BI in parallel
    using R too!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还从 Power BI 内部并行查询了 Bing Maps Locations API，并使用了 R 语言！
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to query RESTful web services using Python
    and R. In addition to learning how to execute raw `GET` requests with both languages,
    you've also learned how to parallelize multiple calls to the same endpoint by
    taking advantage of the multithreading capabilities of your machine. Moreover,
    you've also come across some SDKs of the Bing Maps Locations API, both for Python
    and R, which make accessing the data much easier. Finally, you've seen how all
    of this is easily implemented in Power BI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 Python 和 R 查询 RESTful 网络服务。除了学习如何使用这两种语言执行原始的 `GET` 请求外，您还学习了如何利用机器的多线程能力并行调用同一端点的多个调用。此外，您还遇到了
    Bing Maps Locations API 的 Python 和 R SDK，这些 SDK 使得访问数据变得更加容易。最后，您看到了如何在 Power
    BI 中轻松实现所有这些。
- en: In the next chapter, you'll see how to enrich your data by applying complex
    algorithms to the data you already have. In this way, you will create new variables
    that give a new light to your data, making it more useful to reach your goal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解到如何通过应用复杂算法到您已有的数据来丰富您的数据。这样，您将创建出新的变量，为您的数据带来新的视角，使其更有助于实现您的目标。
- en: References
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For additional reading, check out the following books and articles:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阅读，请查看以下书籍和文章：
- en: '*What RESTful actually means* ([https://codewords.recurse.com/issues/five/what-restful-actually-means](https://codewords.recurse.com/issues/five/what-restful-actually-means))'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*RESTful 实际上意味着什么* ([https://codewords.recurse.com/issues/five/what-restful-actually-means](https://codewords.recurse.com/issues/five/what-restful-actually-means))'
- en: '*Bing Maps REST Services* ([https://docs.microsoft.com/en-us/bingmaps/rest-services](https://docs.microsoft.com/en-us/bingmaps/rest-services))'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Bing Maps REST 服务* ([https://docs.microsoft.com/en-us/bingmaps/rest-services](https://docs.microsoft.com/en-us/bingmaps/rest-services))'
- en: '*A Future for R: A Comprehensive Overview* ([https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html](https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html))'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*R 的未来：全面概述* ([https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html](https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html))'
- en: '*[VIDEO] Accessing API and web service data using Power Query* ([https://www.youtube.com/watch?v=SoJ52o7ni2A](https://www.youtube.com/watch?v=SoJ52o7ni2A))'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*[视频] 使用 Power Query 访问 API 和网络服务数据* ([https://www.youtube.com/watch?v=SoJ52o7ni2A](https://www.youtube.com/watch?v=SoJ52o7ni2A))'
- en: '*Invoking M Functions In Parallel Using List.ParallelInvoke()* ([https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/](https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/))'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用 List.ParallelInvoke() 并行调用 M 函数* ([https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/](https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/))'
